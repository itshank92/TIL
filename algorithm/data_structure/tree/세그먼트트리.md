# 세그먼트 트리 만들기

출처: https://www.crocus.co.kr/648





### 세그먼트 트리는 무엇이고 언제 사용하는가(왜 만들어졌는가?)

수열이 존재할 때, 해당 수열을 가지고 할 수 있는 많은 일들 가운데 하나는 바로 **부분합을 구하는 것**이다. 

* **부분합**이란 **특정위치 `i`부터 `j`까지의 인자들의 합을 구하는 것**이다.     



이 부분합을 구하는 일에 대해서 시간이 얼마나 걸리는지 생각해보자

`N`개의 요소로 이뤄진 배열 `arr`이 있고 `arr`의 `i`부터 `j`까지의 합을 구하는 것은 `O(N)`이 걸린다.

* `i`부터 `j`까지 더하기 위해서는 해당하는 위치의 원소들을 각각 읽어야 한다.  
* `i`부터 `j`까지의 최악의 경우는 시작부터 끝까지이므로 `N`번의 조회가 필요하다.        



이렇게 부분합을 구하는 행위를 여러번(`M`번) 수행해야 하는 경우 시간 복잡도는 `O(MN)`이 된다.      

그리고 바로 이러한 **부분합 연산의 시간복잡도를 단축**시키기 위해서 등장한 것이 **세그먼트트리**다.        





### 세그먼트트리의 등장

위에서 수열에서 부분합을 구할 때의 시간복잡도는 `O(N)`이고 이를 `M`번 반복하는 경우 `O(MN)`이 된다는 것을 확인했다.

세그먼트트리의 경우 **구간별로 미리 부분합을 구해놓는 전처리**를 통해서 부분합을 구하는 연산의 시간복잡도를 줄인다. 

* 세그먼트 트리에서 부분합을 `M`번 구하는 시간복잡도 `O(MlogN)`



### 세그먼트 트리의 구조

![img](세그먼트트리.assets/2232BA4058BF0B8420)

(이미지 출처: https://www.crocus.co.kr/648)

* 세그먼트트리의 리프 노드로는 **입력 데이터의 각 요소값**이 위치한다. (인덱스 순서대로)
  * 각 요소값  ▶ 초록색 숫자  //  각 요소에 해당하는 인덱스  ▶ 검은색 숫자



* 부모 노드는 자식 노드가 가진 인덱스의 포괄적 범위의 합이다.
  * 0~1의 경우 입력데이터 **인덱스 0번의 값(3) + 인덱스 1번의 값(5)** 으로 **8**이 된다.   
  * 노드 안의 **x~y**의 의미는 (입력데이터) **인덱스 x번부터 y번까지의 합**을 의미한다.        



* 따라서 가장 최상위 루트 노드는 입력데이터의 시작부터 끝까지의 합이다. (입력데이터의 총 합을 의미)



### 세그먼트 트리의 생성

* 기본적으로 세그먼트 트리는 배열을 통해서 구현한다.
* 세그먼트 트리는 **대부분 완전 이진트리**이기에 **인덱스를 1번부터 시작하면 부모 자식 관계를 편하게 계산 가능**하다.
  * 부모 인덱스가 `i`일 때, 왼쪽 자식의 인덱스는 `i*2`, 오른쪽 자식의 인덱스는 `i*2+1` 이 된다. 



* 정리하면 배열을 통해 세그먼트 트리를 만드는데, 이 때 부모와 자식 사이에 인덱스를 매개로 연결 관계가 형성된다. 



* 세그먼트 트리는 부분합의 열매가 주렁주렁 열린 트리이고, **부모는 자식 열매들의 포괄 구간합**이 된다. 
  * 즉, 재귀를 통해서 가장 아랫단부터 내려갔다가 올라오면서 부모님을 업데이트 해주는 형식으로 생성할 수 있다.    
  * 부모를 업데이트 해주기 위해서는 **부모 인덱스에 해당하는 메모리 공간이 유효**해야 한다.
  * 즉, **미리 세그먼트 트리의 메모리 공간을 만들어줘야 한다.**
  * ※ 빈리스트의 경우, 인덱스를 통해 배열의 특정 공간에 접근할 수 없다. (아예 공간이 없기에)



* 이를 위해서 **미리 세그먼트 트리의 크기를 예상**해서 **의미없는 값으로 초기화된 배열을 만들어야 한다**.       

​       



### 세그먼트 트리 크기 예상하기

**세그먼트 트리의 전체 크기를 미리 예상해서 배열을 만들어준다.**



> 세그먼트트리로 사용할 메모리 공간 할당을 위해 크기 예상하기

**[ 1. 세그먼트 트리의 계층(layer)구하기 ]**

* N = 12일 때의 **세그먼트 트리의 전체 크기(배열 사이즈 정하기)**를 구하기 위해서는 **2^k로 12보다 바로 큰 값을 만들 수 있는 k**를 찾아야한다. ▶ 즉, k는 4이다



**[ 2. 전체 세그먼트 트리의 크기(노드의 갯수)를 구하기 ]**

* 그리고 난 뒤 **2^k를 하면 16이 되고 16에 \*2**를 하면 우리가 원하는 세그먼트 트리의 크기를 구할 수 있다.  

  → 우리가 구한 세그먼트 트리의 계층은 구간들을 넣을 공간인데 가장 아랫단에 있는 해당 구간 노드의 자식들로 각 값들을 가진 노드들이 온다면, 계층은 1단계 더 높아지고 따라서 2^k에 *2를 한 것이 전체 크기가 된다.      





### 세그먼트 트리 만들기

* 세그먼트 트리는 배열로 만든다

* 우리는 **포인터를 사용한 동적 할당을 통한 트리(연결리스트 형태의 트리)가 아닌 배열로 트리를 만든다**.

* 그 이유는 **세그먼트 트리**는 **full binary tree**에 가깝기에 **배열에 모든 값들이 꽉꽉차서 올 가능성이 매우 높기**때문에 배열을 이용해서 만들 수 있기 때문에 배열을 사용하는 것이다.→ **배열로 구현할 때 더 쉽다.**
  * 세그먼트 트리는 대부분 **완전 이진트리 형태**로 구성된다.      





* 우리는 세그먼트 트리를 형성할 때 **루트 노드**를 **트리 배열의 인덱스 1번**으로 생각한다.

* 이때 **루트노드 왼쪽 노드는** **인덱스 2번** 노드가 될 것이고 **오른쪽 노드는 인덱스 3번** 노드가 될 것이다.

* 그리고 **인덱스 2번 노드의 왼쪽 노드**는 **인덱스 4번 노드**, **오른쪽 노드는 인덱스 5번 노드**가 될 것이다.

* 또한 **인덱스 3번 노드의 왼쪽 노드는 인덱스 6번 노드**, **오른쪽 노드는 인덱스  7번 노드**가 될 것이다.     

​     



**<< 현재 노드의 번호가 node 일 때 >>**

노드의 왼쪽 자식 배열 번호 :: **node \* 2**

노드의 오른쪽 자식 배열 번호 :: **node \* 2  + 1**

▷ **각 노드의 왼쪽 자식과 오른쪽 자식으로 분리되는 과정**을 보여주는 것이다.

▷그리고 **왼쪽 자식쪽에는 start ~ mid**를 보내고, **오른쪽 자식에는 mid+1 ~ end**를 보낸다. 
     (mid =  (start + end) // 2)      

​      





## 실제 세그먼트트리 만들어보기



**[ 입력배열 ]**

`arr = [3, 5, 6, 7, 2, 9, 4, 5, 2, 8, 1, 5]`



**[ 새그먼트 트리 만드는 함수 function ]**

```
function(arr, tree, tidx, start, end)
```

* arr:  입력 배열
* tree:  세그먼트트리 배열
* tidx:  트리 인덱스
  * tidx*2:  왼쪽자식인덱스 
  * tidx*2 + 1:  오른쪽자식인덱스 
* start:  입력 배열의 부분합 시작위치
* end:  입력 배열의 부분합 종료위치      



**[ 새그먼트 트리 생성 함수(function) 작동 원리 ]**

* 입력 배열의 부분합 구간을 계속해서 반으로 분할해서 재귀적으로 function함수를 호출한다.
  * 이때 두 구역으로 나눈 값의 합으로 `tree[tidx]`를 할당한다. 
* 이때 트리 인덱스의 값은 왼쪽 자식 (`start` to `mid` 범위에 해당)의 경우 `tidx * 2`로 하고 
  오른쪽 자식(`mid+1` to `end` 범위에 해당)의 경우 `tidx*2+1`로 한다.
* 이렇게 나누다가 범위의 크기가 1이 되는 경우(=`start`와 `end`가 같아지는 경우) 해당 값을 반환한다.     





**[  분할이 종료되는 시점 추가 설명 ]**

* 노드가 계속 분할되어 결국 `start`와 `end`가 같아지는 부분이 생길 것이다.

* 이때 의미는 `arr[start~end]`가 결국 `arr[start]`와 같다는 의미이고, 결국 노드의 범위가 `1`인 리프 노드를 의미한다.

* 따라서 가장 아래까지 내려왔다면 현재 `tidx`번째인 `tree[tidx]`에 `arr[start]`값을 대입해준다는 의미이다.

* 이러한 과정을 구현하여 재귀적으로 반복하면 새그먼트 트리가 완성된다.     







### 새그먼트 트리 만들기

``` python
# 로그를 만드는 여러가지 방법1
def make_log1(x,b):
    if x < b:
        return 0
    # 차원이 늘어날 때마다 +1해주고 재귀
    return 1 + make_log(x/b,b)

# 로그를 만드는 여러가지 방법2
def make_log2(x):
    n = 1000000
    return n * ((x ** (1/n)) - 1)  #n1n1 사이에 x들어갔다고 기억



def make_sgtree(input_list, tree_list, idx, start, end):
    """
    input_list: 입력배열
    tree_list: 세그먼트트리(배열로 구현)
    idx: 세그먼트트리용 인덱스
    start: 범위의 시작위치(입력배열의 인덱스값)
    end:범위의 끝 위치(입력배열의 인덱스값)
    """
    
    # 종료조건
    if start == end:
      print(idx, start)
      tree_list[idx] = input_list[start]
      return tree_list[idx]
    
    # 중간위치
    mid = (start + end)//2
    
    # 트리업데이트
    # ※주의※  범위 분할시 (start, mid), (mid, end)가 아닌 (start, mid), (mid+1, end)
    tree_list[idx] = make_sgtree(input_list, tree_list, idx*2, start, mid) + make_sgtree(input_list, tree_list, idx*2+1, mid+1, end)
    
    # 트리값 반환
    return tree_list[idx]


#-----------------------------------------------#
# 입력값
i_list = [3, 5, 6, 7, 2, 9, 4, 5, 2, 8, 1, 5]

# 세그먼트트리용 배열생성
l = round( make_log2(len(i_list)) / make_log2(2) )
tree = [0]*(2**(l+1))

# 수행
# ※주의※ //2의 관계로 부모, 자식 인덱스 갖추려면 노드 인덱스는 1부터 시작해야 한다.
make_sgtree(i_list,tree,1,0,len(i_list)-1)

# 결과 
print(tree)

#=> [0, 57, 32, 25, 14, 18, 11, 14, 8, 6, 9, 9, 9, 2, 9, 5, 3, 5, 0, 0, 7, 2, 0, 0, 4, 5, 0, 0, 8, 1, 0, 0]

# 해석: 인덱스 n번의 자식은 인덱스 n*2, n*2+1번으로 부모는 자식들의 합이 된다.
```



**[위에서 주의해야 할 부분!]**

* **트리의 시작 인덱스는 1이다.** 
* 우리는 부모와 자식간의 관계를 `parent_index의 자식 = parent_index*2 , parent_index*2 +1`로 설정했기 때문에 시작 인덱스가 1이 되어야 한다. 







### 입력값 수정시 세그먼트 트리 업데이트 (Update 구현)



```python
def update(tree, tree_idx, start, end, idx, diff):
    """
    tree : 세그먼트트리
    tree_idx: 세그먼트트리 인덱스
    start: 입력값 시작 위치
    end: 입력값 최종 위치
    idx: 수정된 값의 인덱스
    diff: 수정된 값과 이전 값의 차이
    
    ▶ 수정된 값의 인덱스가/ 속하는 범위의 합을 저장하고 있는 트리값을/ 수정해준다
    ▶ 세그먼트 트리의 각 범위를 나눴던 과정을 그대로 수행하면서, idx가 해당 범위에 속하면,
       그 속하는 트리의 값에 diff를 반영해준다.
    """
    
    
    # 종료조건(바꾸려는 값이 start와 end 사이에 없는 경우)
    # 아무것도 하지말고 그냥 끝냄(해당 범위에서는 더 이상 가능성이 없다)
    if start > idx or idx > end:
        return
    
    # 범위내의 경우
    # 해당 tree의 값에 diff를 반영해준다.
    tree[tree_idx] += diff
    
    # (범위내에 있고)시작과 끝이 다른 경우 == 범위를 더 나눌 수 있는 경우
    # 범위를 더 나눈다.
    if start != end:
        mid = (start + end)//2
        update(tree, tree_idx*2, start, mid, idx, diff)
        update(tree, tree_idx*2+1, mid+1, end, idx, diff)

```



실제 수정을 수행해보자

* 입력데이터▷ `i_list = [3, 5, 6, 7, 2, 9, 4, 5, 2, 8, 1, 5]`
* 세그먼트트리 ▷ `tree = [0, 57, 32, 25, 14, 18, 11, 14, 8, 6, 9, 9, 9, 2, 9, 5, 3, 5, 0, 0, 7, 2, 0, 0, 4, 5, 0, 0, 8, 1, 0, 0]`
* ※ 수정 사항: 우리는 입력데이터 인덱스 4번에 있는 `2`를 `10`으로 바꿀 것이다.

* 세그먼트트리 생성 방식과 동일하게 전체 영역`(0 ~ len(i_list)-1)`을 이진탐색을 통해 범위를 분할하면서 해당 범위에 수정하려는 값의 인덱스(`idx`)가 포함되어 있는지 확인한다.
* 함수가 전체 범위로 시작하기에 트리의 인덱스 값(`tree_idx`) 역시 전체 범위를 담고 있는 `1`부터 시작해야 한다. 
  * `tree_idx = 1` , `start = 0` , `end =  len(i_list)-1` , `idx =  4` , `diff = 10 - 2 (= 8)`

```python
# (입력데이터의) 4번 인덱스의 값을 2에서 10으로 바꾼 경우

update(tree, 1, 0, len(i_list)-1, 4, 8)

print(tree)

#=> [0, 65, 40, 25, 14, 26, 11, 14, 8, 6, 17, 9, 9, 2, 9, 5, 3, 5, 0, 0, 7, 10, 0, 0, 4, 5, 0, 0, 8, 1, 0, 0]
```





### 세그먼트트리를 사용해서 어떤 범위의 합을 구하는 방법(Sum 구현)

​      

#### 기본 방식에 대해 이해

* 우리는 **합을 구하고자 하는 범위(대상범위)는 그대로 둔 채** 계속해서, **전체 범위를 반으로** 쪼갠다.

  * 전체 범위를 반으로 쪼개는 행위는 트리의 각 노드에 해당하는 범위를 위에서부터 순차적으로 방문하는 것과 같다.

* 이렇게 **쪼개진 범위와 대상 범위를 비교**해서, **쪼개진 범위가 대상 범위에 모두 포함**될 때, 해당 범위의 합을 가진 트리의 노드값을 결과값에 더해준다.

  * 우리는 이진 분할을 통해서 전 영역을 빠짐없이 독립적으로 쪼개고 있다. 

    = 쪼개진 조각간에 범위가 겹치는 일은 없다. 

  * 따라서 어떤 부분이 대상 범위에 모두 해당하는 경우 해당 조각의 합을 결과값에 더해준다.





#### 쪼개진 조각의 범위와 대상 범위간의 관계는 4가지가 존재한다.

합을 구하려는 범위(left, right)와 트리의 노드가 포함하는 범위(start,end)를 대조했을 때 나오는 경우는 4가지가 존재한다    



1. 합을 구하려는 범위(left, right)와 트리의 해당 노드가 포함하는 범위(start,end)가 **아예 겹치지 않는 경우**

   ▶ 조건식: `if right < start or left > end`

   ▶ 반환식: `return 0`     **>> 해당 트리의 값에서는 얻을 게 없다.**



   (트리 ⊂ 합의 범위)

2. 합을 구하려는 범위(left, right)가 트리의 해당 노드가 포함하는 범위(start,end)를 **완전히 포함하는 경우**

   → **해당 조각은 더 이상 쪼갤 필요가 없다. 바로 결과값에 더해줄게.**

   ▶ 조건식: `if left <= start and  end <= right`

   ▶ 반환식: `return tree[tidx]`   **>> 해당하는 트리의 값을 반환한다.**     



   (합의 범위 ⊂ 트리 )

3. 트리의 해당 노드가 포함하는 범위(start,end)가 합을 구하려는 범위(left, right)를 완전히 포함하는 경우

   → **해당 조각은 더 쪼갤 필요성이 있다.**

   ▶ 조건식: `if start <= left and  right <= end`

   ▶ 반환식: `return sum(tree, tidx*2, start, mid, left, right) + sum(tree, tidx*2+1, mid+1, end, left, right)`       **>> 트리의 범위를 반으로 분할해서 두 영역에 대해 재귀를 호출한다.**



4. 합을 구하려는 범위(left, right)와 트리의 해당 노드가 포함하는 범위(start,end)가 겹쳐져 있는 경우

   → **해당 조각은 더 쪼갤 필요성이 있다.** 

   ▶ 조건식: 1,2,3번 경우가 아닌 경우( `else` )

   ▶ 반환식: `return sum(tree, tidx*2, start, mid, left, right) + sum(tree, tidx*2+1, mid+1, end, left, right)`      **>> 트리의 범위를 반으로 분할해서 두 영역에 대해 재귀를 호출한다.**       



> 코드

```python
def sum(tree, tidx, start, end, left, right):
    """
    tidx: 현재 범위의 합을 가지고 있는 트리 노드의 인덱스 값
    start: 입력리스트의 범위 시작 위치
    end: 입력리스트의 범위 종료 위치
    left: 찾으려는 합의 시작 인덱스 
    right: 찾으려는 합의 종료 인덱스
    """
    
    # 완전 남남인 경우 그냥 지나감
    if right < start or end < left:
        return 0
    
    # 찾으려는 범위 안에 현재 트리 노드가 포함하는 범위가 속하는 경우 (트리 ⊂ 찾으려는 범위)
    # 해당 트리 값(트리 범위의 합)을 반환한다.
    # 그러면 해당 트리가 커버못하는 트리 범위의 양 옆부분에 해당하는 찾으려는 범위는 어떻게 하는가?
    # 걱정할 것이 없는것이 우리는 이진분할을 수행하고 있기에 놓치게 되는 범위는 존재할 수 없다.
    if left <= start and end <= right:
        return tree[tidx]
    
    # 트리 안에 찾으려는 범위가 포함되어 있거나 걸쳐 있는 경우
    # 이진 탐색을 통해 유효한 범위를 찾을 때까지 수행한다.
    mid = (start + end)//2
    return sum(tree, tidx*2, start, mid, left, right) + sum(tree, tidx*2+1, mid+1, end, left, right)
```



