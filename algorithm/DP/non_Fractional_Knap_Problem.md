# 쪼갤수 없는 배낭 문제

출처: 파이썬 알고리즘 인터뷰 5부(알고리즘파트) 23장(다이나믹 프로그래밍)의 632page      



> 문제

15kg 배낭이 있다. 5개의 짐에 대해 각각의 가격과 무게 정보가 주어질 때, 최대로 담을 수 있는 가격을 구해라.

   

> 입력값

```
cargo = [(4,12),(2,1),(10,4),(1,1),(2,2)]  

# 순서대로 (가격,무게) 정보를 의미한다.
```

   

> 방법에 대한 생각

* 브루트포스: 모든 경우의 수(2^n)를 확인하면서 가능한 최대 가격 정보를 확인하는 방법
  
* 비트연산을 사용해볼 수 있겠다.   
  
    
  
* 다이나믹 프로그래밍

  * 각각의 짐별로 순회한다.(각각의 짐이 행(row)이된다.)

    * 가방의 공간을 1kg무게 단위로 쪼개서 각각의 단위를 열(column)로 한다.
    * 각 열에서 최대로 얻을 수 있는 짐의 가격을 해당 열 위치(cell)에 넣는다.

  * 각 열에서 최대로 얻을 수 있는 짐의 가격

    * 현재 짐의 무게가 각 열의 번호(가방의 공간크기) 이하인 경우
      * 현재 짐의 가격 + 이전 행에서 현재 열의 번호에서 현재 짐의 가격을 뺀 곳의 가격정보
      * (이전 행: 이전의 짐들에 대해서 각 가방의 무게별로 최대값을 저장해 놓은 행)
    * 현재 짐의 무게가 각 열의 번호를 초과하는 경우 
      * 이전 행에서 현재 무게에 해당하는 열의 값을 가져온다.
      * 즉, 현재 짐을 넣지를 못하니까 이전의 짐들을 가지고 만든 최대값을 가방에 넣는 것

    



  

> 코드

```python
def zero_one_knapsack(cargo):
  capacity = 15
  pack = []
  
  ## 짐의 갯수로 각 행을 만든다.(i-1은 짐 포인터 & i는 짐의 갯수를 의미)
  for i in range(len(cargo)+1):
    pack.append([])
    ## 가방의 용량별로 각 열을 만든다.(c는 가방 용량 포인터)
    for c in range(capacity + 1): 
      # 짐이 하나도 없거나 가방의 용량이 0일때는 그 어떤것도 넣지 못하기에 0을 넣는다.  
      if i == 0 or c == 0: 
        pack[i].append(0)
      # 현재 가방의 용량(c)이 짐의 무게(짐배열[i][1])를 커버할 수 있는 경우  
      elif cargo[i-1][1] <= c:
        # 현재 무게의 이전 최대값 vs 현재 짐의 가격 + (짐의 용량 - 가방무게)의 이전 최대값    
        pack[i].append(
            max(
                cargo[i-1][0] + pack[i-1][c-cargo[i-1][1]],   #(순서대로) 현재 짐의 가격 + 이전짐의 갯수의 가방의 현재 무게에서 현재 짐의 무게를 뺀 무게에 담겨있는 (이전)짐들의 최대가격  
                pack[i-1][c]  # 현재 위치의 가방에 담겨있는 (이전)짐들의 최대 가격
            )
        )
      # 현재 가방의 용량(c)보다 짐의 무게(짐배열[i][1])이 더 무거운 경우
      else:
        pack[i].append(pack[i-1][c])
  
  # 결과를 눈으로 확인하기 위한 print문
  print(*pack, sep = "\n")
  print("------------------------------------")
  
  # 최종적으로 원하는 것은 모든 짐에 대해 최대 가방용량을 적용했을 때 최대 가격
  return pack[-1][-1]








cargo = [(4,12),(2,1),(10,4),(1,1),(2,2)] # (가격,무게) 순서로 구성되어 있다
zero_one_knapsack(cargo)


### 결과값 ###
"""
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4]
[0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 6, 6, 6]
[0, 2, 2, 2, 10, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12]
[0, 2, 3, 3, 10, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13]
[0, 2, 3, 4, 10, 12, 13, 14, 15, 15, 15, 15, 15, 15, 15, 15]
"""
```

   





> 코드 설명

* 짐의 갯수가 0번부터 시작하는 이유

  * 모든 짐은 이전의 짐이 만들어 놓은 기록(`i-1`)과 비교작업을 수행하는데 이때 첫번째 짐의 경우 비교할 대상이 없다.

  * 따라서 첫번째 짐만 예외적으로 코드를 작성해야 한다.

  * 이것이 귀찮으니까 `i`를 짐의 포인터가 아닌 짐의 갯수를 의미하게 하고 `i-1`을 짐의 포인터로 사용했다.

    * `i`가 0인 경우는(= 짐이 0개 = 가방에 넣을 짐이 없는 경우) 자동적으로 0이 채워지도록 작성    

    

* 열의 무게가 0번부터 시작하는 이유
  
  * 일단 해당 코드는 각 짐을 행으로 순회하면서 가방의 각 용량별 들어갈 수 있는 최대 가격을 찾는 방식으로 작동한다.
    * 이때 현재 짐이 해당 가방 용량에 들어갈 수 있을 때 최대값을 찾기 위해 비교작업이 수행된다.
    * 이 비교작업의 한쪽 대상은 (이전 짐들을 대상으로) 해당 가방 용량에 넣은 최대 가격(`pack[i-1][c]`)이다.
    * 다른 대상은 현재 짐의 가격(`cargo[i-1][1]`)  + (이전 짐들을 대상으로) 현재 가방 무게 - 현재짐의 무게에서의 최대 가격(`pack[i-1][c-cargo[i-1][0]]`)이다.
  * 이러한 비교작업에 있어 무게가 0인 열이 있다면 **순수 무게 대결**이 가능해진다.
    * 순수 무게 대결은 현재 짐이 가방의 모든 공간을 차지하며 들어갈 수 있는 경우, 현재 짐의 가격과 해당 가방 공간의 이전 최대 가격과 대결하는 것을 뜻한다.
    * 이러한 대결이 가능하려면 0kg에 대한 가격 정보가 있어야 한다.
  * 순수 무게 대결이 중요한 이유는 무게 비교 작업 코드에서 **순수 무게 대결만을 위한 별도의 상황설정을 안해줘도 된다는 것이다.**



* 결국 짐의 갯수를 나타내는 행과 가방의 무게를 나타내는 열이 **모두 0번부터 시작하는 이유**는 모든 짐과 무게에 대해서 **예외 상황을 자동으로 처리하도록 하기 위함**이다.

