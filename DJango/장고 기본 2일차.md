# Model



> 기초 공사

* 모델
  * 모델과 데이터 베이스는 다르다
  * 장고는 모델을 통해 데이터 베이스에 접속하고 관리된다
  * 일반적으로 **각각의 모델은 하나의 데이터 베이스 테이블에 매핑**된다.     



* 데이터 베이스
  * 체계화된 데이터의 모임    



* 쿼리
  * 데이터를 조회하기 위한 명령어
  * 조건에 맞는 데이터를 추출하거나 조작하는 명령어    



> 데이터 베이스의 기본 구조

* 스키마(Schema)

  * 데이터베이스에서 자료의 구조, 표현방법, 관계 등을 정의한 구조

    ▶ **데이터 베이스의 전반적인 구조를 명세한 MetaData**가 바로 스키마(Schema)다.    



* 테이블
  * 필드(Field) = 컬럼(Column) = 속성
  * 레코드(Record) = 행(Row) = 튜플    



> (DB) 테이블의 규칙

* [열 규칙] 각각의 열에는 고유한 데이터 형식이 있다.

  ▶ 그 데이터 형식에 맞는 데이터만 입력가능하다.    



* [행 규칙] 테이블의 데이터는 행에 저장된다.

  * 즉, User라는 테이블에 4명의 고객정보가 저장되어 있다면 Row는 4줄이다.

    (각각의 고객은 하나의 줄(Row)로 저장됨)



* [PK 규칙] PK (Primary Key)는 반드시 존재해야 하는 필드(칼럼)다.

  * PK는 각 레코드(행)의 고유값을 담는 필드(칼럼)다.  

  * PK는 반드시 설정하여야 하고, 데이터 베이스 관리 및 관계 설정시 매우 중요하게 활용된다.

    ▶ 각 행은 각각 고유한 객체에 대한 정보이고 이를 명확하게 구분해주기 위해 각 행마다 유니크한 값을 주는 것이 PK의 역할이다.    





> 모델은 무엇인가

* 웹어플리케인션의 데이터를 구조화하고 조작하기 위한 도구

* 모델을 통해서 데이터 베이스의 데이터들을 조작한다.     





> ORM_모델을 통해 데이터 베이스를 조작하는 방식

* ORM은 객체 지향 프로그래밍 언어를 사용해서 호환되지 않는 유형의 시스템(ex_Django - SQL)간에 데이터를 교환하는 방식이다. 

* 쉽게 말해 Django로 만든 프로젝트(웹사이트)에서 DB를 연결하고 DB를 통제하는데 사용하는 방식이 ORM이다.

* 좀 더 자세히 설명하자면 Django의 Python 명령어를 ORM으로 번역하고 이를 SQL로 번역해서 DB를 관리한다.

  [ `Django의 Python 명령문` → `ORM`(이후 내부적으로 SQL문으로 변경됨) → `DB관리` ]

* Object Relational Mapping







> ORM의 장점과 단점

* 장점

  * SQL을 잘 알지 못해도 DB의 조작이 가능하다.

  * SQL의 절차적 접근이 아닌 객체 지향적 접근으로 인해 높은 생산성이 보장된다.

    (기존의 SQL문이 가진 생산성을 뛰어넘을 수 있다)



* 단점
  * ORM이 모든 SQL문을 대체하는 것이 아니므로 특정 서비스의 경우 SQL문으로 구현해야 한다.



* 결과
  * 현재 웹 프레임워크의 가장 중요한 이슈는 **웹개발의 생산 속도**를 높이는 것으로 ORM은 이러한 환경에 있어 매우 중요한 기능이다.→ 단점이 있어도 장점이 너무 큰 ORM



[ORM의 사용 목적]

**"우리는 DB를 객체(Object)로 조작하기 위해 ORM을 사용한다."**



> Model을 생성

모델은 app 하위 요소로 app 디렉토리의 models.py에 작성한다.

```python
from django.db import models

class Article(models.Model):
    # 각 변수는 칼럼으로 들어간다(Primary Key(PK)칼럼의 경우 자동으로 입력된다)
    # 각 변수(칼럼)의 데이터 유형은 models 모듈의 데이터 유형 클래스를 사용해서 지정한다.
    # CharField는 제한이 있는 문자열로 max_length가 필수 인자이다!(없으면 오류)
    title = models.CharField(max_length=10) 
    content = models.TextField()
    # 데이터의 작성일과 수정일 칼럼 추가
    # 자동으로 입력값이 넣어지도록 하는 인자 사용(auto_now_add=True)
    # 자동으로 입력값이 넣어지도록 하는 인자 사용(auto_now=True)
    # auto_now: 자동으로 객체가 (매번) 저장될 때마다 해당 field를 수정한다.
    # auto_now_add: 객체가 처음 저장될 때만 해당 field를 수정하고 이후에는 수정하지 않는다.
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
```

​     

​     

​     



## Migration



> 기본

* 장고가 모델에 생긴 변화(ex_ 필드 추가 및 삭제 or 모델 생성 및 삭제 등등)를 반영하는 방법이다.

  ▶ 모델에 생긴 변화를 Migration으로 만들어서 DB에 전달하여 적용시킨다.

  ▶ [모델 변화]  →  [변경사항에 대한 Migration 생성]  →  [DB에 전달하여 적용]



Migration 명령어에는 4가지가 있다.

1. `makemigrations`

   ▶ 모델의 변경사항에 기반하여 Migration을 만들다.

2. `migrate`

   ▶ 만들어진 Migration을 DB에 전달하여 적용시킨다.

   ▶ 모델에서의 변경사항이 DB의 스키마와 동기화(업데이트)가 된다.

3. `sqlmigrate`

   ▶ migration파일(ORM파일)이 SQL로 어떻게 번역되는지 시각적으로 확인할 수 있는 명령어

   ▶ 실제 작동하는 것은 없고 단지 migation파일이 어떤 SQL문으로 번역되는지만 보여준다.

4. `showmigration`

   ▶ 프로젝트 전체의 migration 상태를 확인하기 위해 사용된다.

   ▶ migration 파일들이 migrate 되었는지 안되었는지 여부를 확인할 수 있다.

   ​	(git의 git status와 비슷한 기능이다.)





> makemigrations 명령어 실행시 결과

실제 명령어: `python manage.py makemigrations`

app 디렉토리 안에 migrations 폴더가 생성되고 그안에 순서대로 migration파일이 생성된다.

순서대로 번호가 붙어서 migration파일이 생기는 이유: 버전관리가 가능하다.

해당 파일은 ORM방식으로 작성된 것으로 이후 migrate 명령어 수행시 DB에 전달된다.

▶ 즉, makemigrations은 우리가 만든 모델(python의 클래스)을 ORM으로 번역해서 migration파일로 만드는 명령어다.



> migration 실행시 결과



프로젝트의 DB(`db.sqlite3`)내에`어플리케이션이름_모델이름`의 이름을 가진 테이블이 생성된다.



> sqlmigrate

실제 명령어: `python manage.py sqlmigrate articles 0001`



> showmigration

실제 명령어: `python manage.py showmigrations`



---



## Database API



* Database-abstract API or Database-access API



* 데이터 베이스와 대화하기 위한 것 (= DB를 조작하기 위한 명령어)



* 모델 생성시 데이터 베이스 테이블을 읽고 수정할 수 있는 DB-Abstrat-API가 (자동으로) 생성된다





> 문법

형태: `모델(클래스)이름 . objects.  API의 쿼리문() `

예시: `Article.objects.all()`

결과: 해당 쿼리문에 맞는 데이터를 반환한다. 



> objects

* 장고 모델의 **데이터 베이스 쿼리문들이 저장되는 공간**(인터페이스)

* manager라고도 불린다. (`모델`과 `데이터베이스 명령어`(API쿼리문)를 연결하는 역할)



> 쿼리셋

* 쿼리문을 통해 데이터베이스로부터 전달받은 데이터 목록(객체 목록)
  * 쿼리셋안의 데이터(객체)는 0개, 1개 혹은 여러개일 수 있음

* 데이터베이스로부터 조회, 필터, 정렬 등을 수행할 수 있다.

* 쿼리셋은 기본적으로 리스트로 여러 ROW들을 담을 수 있다.
  * 쿼리셋은 파이썬의 리스트와 비슷하다 ▶ 파이썬의 리스트 조작처럼 조작할 수 있다

* API 명령문에는 여러 줄(**쿼리셋**)을 가져오는 API쿼리문이 있다. 

* 반대로 쿼리셋이 아닌 **하나의 ROW**만 가져오는 API 쿼리문도 있다. (예시 `get`)





> 장고에서 사용하는 파이썬 shell

* 해당 shell은 기능이 부족해서 다른 모듈을 설치해서 사용하자

* `django-extensions`를 `pip`로 `install`하고 `settings.py`에 해당 어플을 등록하여 사용한다.

  (등록시 이름은 `django_extensions`)

* 명령어: `python manage.py shell_plus`
* 기능: 우리가 장고에서 사용할 만한 모듈을 모두 `import` 해줘서 바로 쓸 수 있게 해준다.





## CRUD



`API 쿼리문`으로 `CRUD`를 수행해보자



> CRUD 기본

* 대부분의 컴퓨터 소프트웨어가 가지는 기본적인 데이터 처리 기능인 Create(생성), Read(읽기), Update(갱신), Delete(삭제)를 묶어서 일컫는 말이다.





> 명령어

`모델이름(클래스이름).objects.API쿼리문()` 

▶ API쿼리문에 해당하는 데이터를 모델과 연결된 테이블에서 찾아서 작업함(생성, 읽기, 갱신, 삭제 등)

▶ (예시) `Article.objects.all()`



API쿼리문으로 `쿼리셋`을 받는 경우, Python에서 리스트를 조작하는 것처럼 조작할 수 있다.







> Create: 데이터를 생성하는 3가지 단계



1. 모델 클래스를 사용해서 instance를 만든다. 

   * 객체 생성시 해당 객체는 아직 DB에 입력된 데이터가 아니기에 id값이 None이다.

     (파이썬 코드상에서만 존재하고 있지 아직은 데이터 베이스에 들어있는 데이터가 아니다.)

   * `article = Articles()`



2. 해당 모델의 필드값을 넣어준다. 
   * 객체.속성 = 값  형태로 넣어준다.
   * `article.title = 'first'`
   * `article.content = 'django'`



3. 이렇게 객체를 생성한 다음 데이터를 입력한다.
   * 데이터 입력이 끝났으면 해당 객체를 DB에 저장하는 명령어(`.save()`)를 실행한다.
   * `article.save()`



★ 이렇게 복잡한 것을 objects에서는 create라는 메소드로 한번에 수행 가능하다. ★

`Article.objects.create(title='title', content='content')`

동작과 동시에 수행됨





# field__lookup



데이터 조회시 좀 더 자세하게 조회할 수 있는 인자들 모음집

API 쿼리문 중 조회 관련 쿼이문인 `get`과 `filer`의 인자로 들어갈 수 있다.



사용 방법:  `field명__사용하려는lookup기능 = 값`





# update



데이터를 불러와서 속성 = 값으로 수정

수정 후에 `.save()` 수행해야됨



# delete

데이터를 불러와서 `.delete()`하면 된다.

※ 삭제후에 새로운 데이터를 넣으면 지워진 id가 아닌 가장 아래의 id로 기록된다.

(삭제된 데이터의 id는 다시 활용되지 않는다.)





# admin

```python
from .models import Article



# admin site에 (Article 모델을) register하겠다.

admin.site.register(Article)
```



모델 등록한 다음 admin에 등록을 해주면 admin 페이지에서 쉽게 관리가 가능하다.