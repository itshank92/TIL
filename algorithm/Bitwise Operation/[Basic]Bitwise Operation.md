## 비트연산자

​     

### 이진수 기본

* 이진수의 비트가 3자리인 경우, (십진수로) `0`부터 `2^3-1`까지 나타낼 수 있다. 
  * `000,001,010, ... 111`  ==  `0,1,2, ... , 7`
* 이진수의 `자리수`를 리스트의 `원소의 갯수`라고 본다면, `이진수로 표현 가능한 수`들은 각각 `리스트의 부분집합`이라고 할 수 있다. 
  * 예를 들면 `새해목표 = ["결혼","취업","아파트구입"]`라는 리스트가 있다고 할 때 이를 이진수의 비트로 보고 `총 경우의 수`(=`부분집합의 수`)와 `각각의 경우`(=`부분집합`)을 구해보자.
  * 리스트의 원소의 갯수가 3개니까 이진수의 비트의 수를 3비트라고 볼 수 있다. 
  * 총 경우의 수(부분집합의 수)는 `2^3`인 `8가지`이다.
  * 각각의 경우는 `0`부터 `2^3-1`이다. 
    * 000 (=0) ▶ `[x, x, x]`
    * 001 (=1) ▶ `[x, x, '아파트구입']`
    * 010 (=2) ▶ `[x, '취업', x]`
    * 011 (=3) ▶ `[x, '취업', '아파트구입']`
    * 100 (=4) ▶ `['결혼', x, x]`
    * 101 (=5) ▶ `['결혼', x, '아파트구입']`
    * 110 (=6) ▶ `['결혼', '취업', x]`
    * 111 (=7) ▶ `['결혼', '취업', '아파트구입']`

* [**결론**] 
  * `n`자리인 경우 부분집합의 갯수는 `2^n`개이다. 
  * `n`자리인 경우 각 경우는 `0`부터 `2^n-1`이다. 



### 쉬프트 연산자 기본

* `<<` 모든 값들을 한칸씩 왼쪽으로 이동시킨다.
  * `0010` 을 `<<` 한 번 수행한 결과: `0100`
  * 이진수 `100`을 나타내는 방법 → `1 << 2`
    * `1<<2`는 `1`을 왼쪽으로 `2`번 이동하는 것이다. 이 때, 이동하며 지나간 곳은 0이 채워진다. 
    * 따라서 `1<<2`는 결국 `100`이 된다. (`1<<1`은 `10`)
  * 이진수 `001`을 나타내는 방법 → `1 << 0`
    * `1<<0`은 1을 왼쪽으로 0번 이동하는 것이다.
    * 따라서 `1<<0`은 결국 `001`(==`1`)이 된다.

* `>>` 모든 값들을 한칸씩 오른쪽으로 이동시킨다.

  * `0100`을 `>>` 한 번 수행한 결과: `0010`

* 쉬프트 연산자(`<<` or `>>`)와 And 연산자(`&`)를 사용해서 확인하고 싶은 자릿수가 1인지 0인지 확인하는 방법

  * `i`라는 이진수(십진수라면 이진수로 자동 바뀜)의 세번째 자리수가 1인지 확인하는 코드

    ```python
    if i & (1<<2):
        pass
    ```

  * `i`라는 이진수와 이진수`100`의 각 자리수를 비교해서 둘 모두 해당 자리수가 `1`인 경우 `1<<2`를 반환하는 식이다. 

  * 해당 자릿수가 1이 아닌 경우 `0`을 반환한다.	

  * 검사하려는 자릿수의 비트가 `1`이면 `True`라서 `1<<j`에 해당하는 **십진수**를 반환, 검사하려는 자릿수의 비트가 `0`이면 `False`라서 **0**을 반환
  
    ```python
    ##이진수 1000(=8)을 1000으로 탐색
    print(8 & (1<<3))
    #▶ 8 (=1000)
    
    ## 이진수 111(=7)을 100으로 탐색
    print(7 & (1<<2)) 
  #▶ 4 (=100)
    ```
  
    



### 쉬프트 연산자 활용

* `a << b` : `a`를 `b`만큼 왼쪽으로 이동(left shift)
  *  `a = (1 << 4) - 1` → 4개의 비트가 모두 1로 채워진 값 구하기
    * 1을 왼쪽으로 4칸 옮김 ▷ 10000
    * 해당 값에 1을 빼줌 ▷ 10000-1 = 1111

* `1 << n `이라는 표현은 `2**n`과 같다. (`n`은 비트 자릿수)

  * 시프트 연산 `a << n`의 결과 값은 `a`에 `2의 n제곱`을 곱해주는 것과 같다. (`a*(2**n)`)

    * 단 자릿수를 초과해서 사라지는 부분이 없는 경우에 한한다. 

  * `1 << n`이 `2**n`과 같기 때문에 `range`의 인자로 사용할 수 있는 것이다.

    ```python
    for i in range(1<<3): ## == for i in range(8):
        print(i, end = " ")
    
    ## 결과값: 0 1 2 3 4 5 6 7
    ```

* `1<<n`는 모든 부분집합의 수를 나타낼 수 있다.
  * `for i in range(1<<n)`을 사용할 수 있다.
  * 이때 `i`는 모든 부분집합을 나타낸다.
  * `n`이 `4`인 경우 `0000` , `0001` , `0010` , `0100` , `1000` , ...이렇게 쭉 나열된다.

* 쉬프트 연산자의 결과 자릿수를 넘어서는 부분은 사라진다. 
  * 예를들어 `1111`에 `>> 2`를 해준 결과는 `0011`이 된다.

   



### 쉬프트 연산자 활용해서 모든 부분집합을 알아보기

​    

> 문제 

재료가 3가지 일 때(n=3) 모든 종류의 라면을 출력하라

​    

> 코드

```python
재료 = ["계란","치즈","떡"]  
n = 3

## 모든 부분집합 i에 대해서 순회 (n이 3이니까 1<<n은 2**3(=8)  >> i는 0부터 7까지)
for i in range(1<<n): 
  ans = ""
  ## j는 0,1,2 (각각 요소의 인덱스 번호)
  for j in range(n):
    # 1<<j는 1, 10, 100 , 각각의 요소가 1인지 확인하고 1이면 ans에 해당 요소를 더해줌
    if i & (1<<j):
      ans += 재료[j] +" "
    
  ## 각각의 부분집합의 경우(i)가 끝나면 ans를 갈무리한다.
  print((ans + "라면입니다.").strip())

    
#### 결과값 ####
"""
라면입니다. - - - - - - - - - >  i=0   1<<j = []
계란 라면입니다. - - - - - - - >  i=1   1<<j = [1<<0]
치즈 라면입니다. - - - - - - - >  i=2   1<<j = [1<<1]
계란 치즈 라면입니다. - - - - - >  i=3   1<<j = [1<<0, 1<<1]
떡 라면입니다. - - - - - - - - >  i=4   1<<j = [1<<2]
계란 떡 라면입니다. - - - - - - >  i=5   1<<j = [1<<0, 1<<2]
치즈 떡 라면입니다. - - - - - - >  i=6   1<<j = [1<<1, 1<<2]
계란 치즈 떡 라면입니다. - - - - >  i=7   1<<j = [1<<0, 1<<1, 1<<2]
"""
```







> 비트연산자 추가

* | : 대응되는 비트 중에서 하나라도 1이면 1을 반환함. (비트 OR 연산)
  * 두 비트를 자리수별로 비교해서 둘 다 0일 때만 0을 반환하고 나머지는 1을 반환한다.

```python
# 8은 이진수로 1000
print(8 | (1<<0)) # 1000 | 0001 ▶ 1001(9)
print(8 | (1<<1)) # 1000 | 0010 ▶ 1010(10)
print(8 | (1<<2)) # 1000 | 0100 ▶ 1100(12)
print(8 | (1<<3)) # 1000 | 1000 ▶ 1000(8)

## 결과값
# 9
# 10
# 12
# 8
```

---



> 보수의 개념과 이해

0. 컴퓨터에서 음의 정수와 양의 정수를 저장하는 방법

   * 컴퓨터는 정수를 **32비트 크기의 2진수** 형태로 저장한다.

     * (예시) 정수 `2`는 `0000 0000 0000 0000 0000 0000 0000 0010`으로 저장한다.
     * (예시) 정수 `10`은 `0000 0000 0000 0000 0000 0000 0000 1010`으로 저장한다. 

   * 그리고 이때 32비트 중 첫째 자리의 수는 **부호**를 의미한다.

     * 첫째 자리의 수가 `0`이면 **양의 정수**, `1`이면 **음의 정수**를 의미한다.       

   * 컴퓨터는 **음의 정수를 `2의 보수` 방식으로 표현**하여 저장하거나 출력한다.

     (자세한 내용은 아래를 읽으면서 이해)



1. 보수의 개념
   * 보수는 보충을 해주는 수를 의미한다.
     * 예를 들면 1에 대한 10의 보수는 9이고 1에대한 2의 보수는 1이다.
   * 그렇다면 **1의 보수**에 대해 한번 생각해보자. 
     * `1`에 대한 `1`의 보수는 `0`이고 `5`에 대한 `1`의 보수는 `-6`이 된다.
     * **1의 보수는 합해서 1이 되는 수**



2. 보수의 규칙
   * **`n의 보수`에 `1`을 더한 것은 `n+1의 보수`**다.
     * 예를 들면 `3`에 대한 `9의 보수`는 `6`이다.
     * `6`에 `1`을 더한 `7`은 `3`에 대한 **10의 보수**가 된다.     
   * 따라서 **1의 보수에 1을 더한 것은 2의 보수가 된다**는 것을 알 수 있다. 





3. **1의 보수**와 **2진수**의 관계 
   * 결론적으로 말하면 **2진수는 1의 보수를 통해 반전**된다. (반전: `0`은 `1`으로, `1`은 `0`으로 바뀌는 것) 
     * **2진수의 1의 보수의 의미**: 2진수의 **각 자리 숫자**가 1이 되기위해 더해줘야 하는 숫자
     * 즉, 0인 경우 1이 더해져야 하고 1인 경우 0이 더해져야 한다. 
   * 2진수에 대한 **1의 보수는 해당 수의 0은 1로, 1은 0으로 바꾼 것**이된다. 
     * `0000 ... 0001`(1)의 1의 보수는 `1111 ... 1110`이 된다.  
   * 앞서 배웠듯 1의 보수에 1을 더하면 2의 보수가 된다. 
   * 따라서 위에서 구한 **1의 보수 값에 1을 더하면 2의 보수가 된다.** 
     * `1111 ... 1110` + `1` = `0000 ... 0001`에 대한 2의 보수





4. 컴퓨터와 보수
   * (복습) 컴퓨터는 정수를 **32비트 크기의 2진수** 형태로 저장한다.
     * (예시) 정수 `2`는 `0000 0000 0000 0000 0000 0000 0000 0010`으로 저장한다. 
   * 이 때 음의 정수의 경우 **2의 보수 표현 방식**으로 저장하거나 출력한다.
     * 예를 들면 정수 `2`의 경우 위에 표현한 것처럼 32비트 크기의 2진수로 저장있다. 
     * 정수 `2`의 **2의 보수**는 음의 정수 `-2`를 의미하게 된다.
     * 정수 `2` =  `0000 0000 0000 0000 0000 0000 0000 0010` 
       ▶ 정수 `2`의 **1의 보수** = `1111 1111 1111 1111 1111 1111 1111 1101`
       ▶ 정수 `2`의 **1의 보수** + **1** = `1111 1111 1111 1111 1111 1111 1111 1110` = **정수2의 2의 보수** 
     * **정수 2의 2의 보수**인 `1111 1111 1111 1111 1111 1111 1111 1110`는 `-2`를 의미한다.



> 컴퓨터에서 2의 보수를 사용해서 음수를 표현하는 이유 

컴퓨터는 덧셈만 수행할 수 있다. 따라서 보수를 통해 음수를 포현해야 덧셈만으로도 뺄샘을 할 수 있게 된다. 

(곱셈은 덧셈을 여러번 수행하는 것이고, 나눗셈은 뺄셈을 여러번 수행하는 것이다)







> 비트연산자의 보수구하기

* `~` : 기호 뒤에오는 수에 대한 **1의 보수**를 구해준다.(`1의 보수 = 2의보수 -1`)

* 컴퓨터에서는 **2의 보수 형태**로 **음의 정수**를 저장한다.

* 따라서 `~어떤정수` + `1`을 해주면 **어떤정수에 대한 2의 보수**가 되고 이것이 바로 `-어떤정수`가 된다.
*  



----

출처

https://opentutorials.org/module/3921/23761

https://pgono.tistory.com/34

https://m.blog.naver.com/PostView.nhn?blogId=nanzz200x&logNo=120188535102&proxyReferer=https:%2F%2Fwww.google.com%2F