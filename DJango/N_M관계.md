### 중계테이블을 자동으로 만들어주는 필드 

### ManyToManyField(모델명)

> 수동으로 중계모델 생성

* 중계모델이 두 테이블의 id 필드들 말고 다른 필드도 가져야 할 때는 만들어서 사용

* 두 테이블(모델)의 이름(소문자로)을 필드로 받고 ForeignKey 사용







> 중계모델생성

`연결모델명+s = models.ManyToMany(연결모델명)`

* ManyToMany의 인자들(모두 옵셔널)
  * through = '실제 중계 테이블명'
    * 중계테이블을 직접 만들었다면 여기에 해당 이름을 적으면 됨
  * related_name = '새로운 모델매니저'
    * 역참조시 적용할 모델매니저 이름 설정
    * 설정 안하면 `역참조대상모델명__set`으로 역참조 가능 
  * symetrical = 아래 설명 참고



동일한 모델을 참조(자기자신을 manytomany로 참조)하는 경우, 중계테이블에  들어가는 데이터는 중복될 필요가 없다.

예를 들면 일반적인 중계테이블은 각각의 모델의 입장에서 연결된 상대방을 적기에 하나의 레코드(row)에 필드가 두개가 존재

하지만 자기자신을 참조하는 경우 같은 데이터를 다른 입장에서 하나의 row에 대해 필드를 2개 넣어줄 필요가 없음

(자기자신을 ManyToManyField로 참조하는 경우 이때 인자는 'self'로 들어간다.)

이렇게 자기자신 참조하는 경우, 역참조시 대상모델명_set으로 작동하지 않음

따라서 symmetrical을 False로 설정 



> 둘 사이 관계 연결

`모델객체.연결모델명s.add(연결모델객체)`

이미 존재하는 관계에 다시 같은 대상을 연결하면 추가되지 않는다.(변화 X)      



* 연결 해제 명령어

`모델객체.연결모델명s.remove(연결모델객체)`



> 연결된 모든 객체 보기

`모델객체.연결모델명s.all()`



> 역참조 방법

* 모든 연결객체 가져오기

`연결모델객체.모델이름_set.all()`

* 연결하기

`연결모델객체.모델이름_set.add(모델객체)`

* 연결끊기

`연결모델객체.모델이름_set.remove(모델객체)`

> ManyToManyField는 어디에 있어도 된다.





1:n관계 용어

target 모델: 1에 해당하는 모델

source모델: n에 해당하는 모델 

