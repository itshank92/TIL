# 리스트 정렬

출처: https://leetcode.com/problems/sort-list    



> 문제

연결 리스트를 O(n log n)에 정렬하라.    



> 입력과 출력

**Example 1:**

![img](58.Sort_List.assets/sort_list_1.jpg)

```
Input: head = [4,2,1,3]
Output: [1,2,3,4]
```

**Example 2:**

![img](58.Sort_List.assets/sort_list_2.jpg)

```
Input: head = [-1,5,3,4,0]
Output: [-1,0,3,4,5]
```

**Example 3:**

```
Input: head = []
Output: []
```

​    



> 생각1 병합정렬

* 연결리스트의 경우 보통 병합 정렬 방식을 사용해서 정렬한다. 

* 병합정렬은 일단 입력 배열에 대해 **중앙을 기준**으로 **계속해서 2개의 덩어리**로 만든다. 

* 연결 리스트의 경우 전체 길이를 알 수 없기에 2개의 덩어리로 나누기 위한 **중앙을 파악하는 작업이 선행**되어야 한다. 

* 중앙을 파악하기 위한 작업은 **러너(Runner) 기법**을 사용한다.

  * 러너(Runner) 기법 쉽게 기억하기 

  * **러너 기법에 등장하는 변수(주체)**에 대해서
    * 총 3개의 변수(주체)가 등장한다.

      → `slow`: 느린 주자, `fast`: 빠른 주자, `half`: 느린주자의 바로 이전 지점

      → 느린주자(`slow`)는 1칸씩 이동하고, 빠른 주자(`fast`)는 2칸씩 이동한다.

    * 느린 주자(`slow`)와 빠른 주자(`fast`)는 출발점이 같다. (=초기값이 `head`로 같음)

    * 느린주자의 바로 이전 지점을 가리키는 변수(`half`)의 초기값은 `None`이다.

      → 느린주자(`slow`)가 아직 출발점(`head`)에 있기에 바로 이전지점은 존재하지 않기 때문

  * **러너기법의 작동 조건**에 대해서

    * 러너 기법은 언제나 빠른 주자(`fast`)가 **다음번에 뛸 위치**가 존재하는 경우에만 작동한다.

    * 이때, 다음번에 뛸 위치는 유효값을 가진 노드뿐만 아니라 마지막 노드에 연결된 `None`을 포함한다.

    * 작동 조건을 코드로 표현하면 다음과 같다. → `while fast and fast.next:`

      ▶ `fast`와 `fast.next`가 존재하는 한, `fast.next.next`는 `유효값의 노드` or `None`이다. 

  * **러너 기법의 예외 상황** 처리 ▷ 가장 앞단에서 처리해야 한다.

    * 러너 기법이 작동하기 위해서는 일단 **전체 연결리스트의 길이가 2 이상**이어야 한다. 

    * 전체 연결리스트 길이가 1이거나 0인 경우 그냥 바로 `head`를 리턴하면 된다. 

    * 예외 상황 처리를 코드로 표현하면 다음과 같다. →  `if head and head.next: `

      → `head`와 `head.next`가 **유효한 값**이어야지 **길이가 2 이상인 연결리스트**가 된다.

  * 러너 기법의 **종료 상황(달리기 종료)**

    * 달리기가 종료되었을 때, 전체 길이가 **짝수**인 경우 `slow`는 **중간 인덱스 중 큰 인덱스**에 위치한다.

      → 이때 `slow`의 직전 위치를 가리키는 변수인 `half`는 **중간 인덱스 중 작은 인덱스**를 가리킨다.

      → 예를 들면 전체 길이가 `6`일때, 전체 인덱스는 `0,1,2,3,4,5`이고 중간 인덱스는 `2`와 `3`이다.

      → 이 때 달리기 종료시, `slow`는 인덱스 `3`에 위치하고 `half`는 `slow`의 직전 위치인 `2`를 가리킨다.

    * 달리기가 종료되었을 때, 전체 길이가 **홀수**인 경우 `slow`는 **중간 인덱스**에 위치한다.

      → 이때 `slow`의 직전 위치를 가리키는 변수인 `half`는 **중간 인덱스 -1**을 가리킨다.

      → 예를 들면 전체 길이가 `5`일때, 전체 인덱스는 `0,1,2,3,4` 이고 중간 인덱스는 `2`다.

      → 이 때 달리기 종료시, `slow`는 인덱스 `2`에 위치하고 `half`는 `slow`의 직전 위치인 `1`을 가리킨다.

* **연결리스트를 두 덩어리로 쪼개기**

  ▶ 러너 기법을 통해 중앙에 있는 노드(`half`)를 구했다.

  ▶ 해당 노드의 `.next`를 `None`으로 함으로서 연결 리스트를 두 덩어리로 끊을 수 있다.

* **쪼갠 두 덩어리에 대해서 다시 재귀 호출**을 한다. 

  * 이 때 재귀호출의 입력값은 **각각 덩어리의 시작 노드**가 된다.
  * 재귀 호출의 결과를 **각각 변수에 할당**한다.(`l1` , `l2`)

* 할당받은 변수들을 **merge(병합) 함수의 인자로 넣고 함수를 수행**한다.

  * `self.mergeTwoLists(l1,l2) `

* **병합 정렬된 두 연결 리스트를 하나로 병합**하는 함수(`mergeTwoLists`) 작동 과정

  * **이 함수는 두 개의 연결 리스트를 하나로 합치는 대표적인 함수다.**

  * 작동 조건: 입력값인 두 연결 리스트( `l1` , `l2` )가 모두 유효한 노드인 경우

      → `if l1 and l2`

    1.각 연결리스트의 현재 노드의 값( `.val` )를 비교해서 작은 노드를 `l1`에, 큰 노드를 `l2`에 할당한다.

    2.작은 노드(`l1`)의  `.next` 를 재귀함수인 `self.mergeTwoLists(l1.next, l2)`에 할당한다.

    3.작동조건과 관계없이 `l1 or l2`를 `return`한다.

    → 둘 중 남아있는 연결리스트가 `return`된다.( `l1` ▷ `l2` 순서로)

    → ~~사실 위의 조건식에서 항상 `l1`이 `.next`로 넘어가는 형태로 작동하기에 항상 `l1`이 `None`이 될 것이다.~~

    → ~~따라서 `return l2`로 해도 된다.~~

    ▶ `return l2`로 하면 안되는 이유

    → 마지막 비교인 경우 `l1.next`는 구조적으로 `None`이 되고 `l2`만 남게된다. (**`l2`가 `return`되어야 함**)
    (항상 작은 노드가 `l1`에 할당되고 `l1`에 대해 `.next`가 호출되기에)

    → 하지만 그 이후 재귀함수가 차례대로 종료하면서 `l1.next`가 재귀함수의 결과값에 할당되는데, 이때 `return` 해야 하는 값은 바로 `l1`이 된다. (**`l1`가 `return`되어야 함**)
    \>\> 항상 비교과정이 수행된다면 (=`l1 and l2`가 만족하는 경우) `l1`에 작은값이 할당되고 해당 값은 `이전 노드`의 `.next`에 해당한다.

    →  따라서 결론적으로 `l1`와 `l2`가 각각 상황에 따라 `return`되어야 하고 이는 `l1` or `l2`로 커버가 가능하기에 코드가 이렇게 작성된 것이다.    



> 코드

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next


class Solution:
    
    #6 두 연결 리스트 병합(정복하기)
    def mergeTwoLists(self,l1,l2):
        if l1 and l2:
            if l1.val > l2.val:
                l1,l2 = l2,l1
            l1.next = self.mergeTwoLists(l1.next,l2)
        return l1 or l2
    
    # 분할하기
    def sortList(self, head: ListNode) -> ListNode:
        #1 러너기법의 예외상황 처리
        ## 괄호주의!!!★
        if not (head and head.next):
            return head

        #2 러너기법 사용 (느린자와 빠른자의 출발점은 똑같다, 느린자의 그림자의 초기값은 none)
        half,slow,fast = None, head, head
        ## 러너기법의 종료조건은 빠른자(fast)가 다음번에 뛸 장소가 없을 때
        while fast and fast.next:
            half, slow, fast = slow, slow.next, fast.next.next

        #3 절반에서 연결 끊기
        ## 연결리스트에서 덩어리를 나눈다는 것은 연결고리를 끊는 것.
        half.next = None

        #4 각 덩어리에 대해서 다시 재귀로 분할
        ## 각 덩어리는 각 덩어리의 시작노드를 통해서 가리킨다.(연결리스트의 특징)
        l1 = self.sortList(head) #앞쪽 덩어리의 시작점
        l2 = self.sortList(slow) #뒤쪽 덩어리의 시작점

        #5 재귀로 얻은 결과값(l1,l2)에 대해 병합 수행
        return self.mergeTwoLists(l1,l2)
```

   

> 코드 설명

* 기본적인 작동과정은 위에 `생각_병합정렬` 파트에서 자세히 정리했다.

* **#1**

  * **러너기법의 예외조건**으로 무조건 `head`와 `head.next`가 존재해야 **1회라도 달리기가 작동**한다.

    :question: `fast`의 초기값이 `head`고 `while`문의 조건이 `fast and fast.head`인데 같은 것 아닌가?

    :arrow_right: 다음에 오는 `half.next`는 `while`문이 1회도 작동안한 경우 `Error`를 발생시킨다.
    (`None`은 `next`라는 `attribute`가 없다는 `Error` 메세지가 나올것)​

  * `not`으로 묶는 것은 `head`뿐만 아니라 `head.next`이기에 괄호를 주의해서 사용한다

* **#2**

  * 러너 기법의 자세한 내용은 위에서 정리하였다. 
  * 한 줄로 할당하는 과정을 잘 생각하자.
    * `half`는 `slow`로, `slow`는 `slow.next`로, `fast`는 `fast.next.next`로 할당
    * `half`는 현재의 `slow`에 할당해야 하고 `slow`는 현재 `slow`의 `next`로 할당해야 한다. 
    * 따라서 `half`를 먼저 `slow`에 할당하고 난 다음 줄에서 `slow`를 `.next`에 할당하던가
      위와 같이 한 줄에서 동시에 할당 할 수 있다. 

* **#3**

  * 연결리스트에서 두 덩어리로 나누는 방법은 중간 노드의 연결을 끊는 것이다.
  * 러너 기법으로 중간을 찾고 해당 중간 노드(`half`)의 `.next`를 `None`으로 한다.

* **#4**

  * 나뉜 두 연결리스트에 대해 다시 분할 함수를 재귀로 호출한다.
  * 연결리스트가 입력값으로 들어갈 때는 항상 `root` 노드가 입력된다.

* **#5**

  * 븐할함수를 재귀로 계속 호출해서 얻은 결과에 대해서 병합을 수행한다.
  * 분할함수의 끝은 더이상 나눌게 없는 상태(노드1개)일 것이다.
  * 따라서 가장 밑단에서 `l1`은 노드1개, `l2` 역시 노드 1개가 된다.
  * 이 노드들에 대해서 병합을 수행한 결과는 길이 2인 연결리스트다.
  * 해당 연결리스트는 또 다시 재귀의 결과물이 된다(`l1` or `l2`에 할당된다.)
  * 따라서 병합은 단순히 개별 노드를 병합하는 것이 아닌 **연결리스트에 대한 병합 함수**로 작성되야한다.

* **#6**

  * 연결리스트에 대한 대표적인 (정렬하는) 병합 함수다.
  * 두 연결리스트가 유효한 경우(현재 노드의 값이 있는 경우) 값이 작은 연결리스트를 `l1`에 할당한다.
  * `l1.next`를 재귀함수에 할당한다.
    * 이때 재귀함수의 인자는 `l1.next, l2`가 된다.
  * 병합함수는 `l1` or `l2`를 `return`한다.
    * 앞에서 설명했듯 `l2`는 마지막 재귀의 결과로 반환받는 값이고, 그 이후 상위 재귀가 지속적으로 종료되면서 반환해야 하는 것은 현재의 작은 노드인 `l1`가 된다. 
    * 따라서 `l1 or l2`로 작성한 것이다.      





> 파이썬 내장 함수 (sort) 사용해서 푸는 방법

* 파이썬의 sort는 Timsort 방식으로 매우 빠른 정렬을 제공한다.
* 전체적인 작동 과정은 다음과 같다.
  1. 연결리스트를 리스트로 바꾼 다음 sort를 수행한다.
  2. (정렬된) 리스트를 다시 연결리스트로 바꿔서 반환한다.

* 내장 함수를 사용하여 빠르게 풀 수 있다는 장점이 있지만 앞서 다룬 병합정렬풀이도 잘 알고 있어야 한다.
  * 실제 화이트보드 코딩시에는 내장함수가 아닌 병합정렬방식으로 풀이를 요구할 것이다.

* 코드

  ```python
  # Definition for singly-linked list.
  # class ListNode:
  #     def __init__(self, val=0, next=None):
  #         self.val = val
  #         self.next = next
  class Solution:
      def sortList(self, head):
          # 연결리스트 -> 리스트
          p = head
          lst = []
          while p:
              lst.append(p.val)
              p = p.next
  
          # 정렬
          lst.sort()
  
          # 리스트 -> 연결리스트
          p = head
          for num in lst:
              p.val = num
              p = p.next
  
          return head
  ```

  