# 최대 슬라이딩 윈도우

출처: https://leetcode.com/problems/sliding-window-maximum   (239번)      



> 문제

배열 nums가 주어졌을 때 k 크기의 슬라이딩 윈도우를 오른쪽 끝까지 이동하면서 최대 슬라이딩 윈도우를 구하라.     



> 입력과 출력

**Example 1:**

```
Input: nums = [1,3,-1,-3,5,3,6,7], k = 3
Output: [3,3,5,5,6,7]
Explanation: 
Window position                Max
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

**Example 2:**

```
Input: nums = [1], k = 1
Output: [1]
```

**Example 3:**

```
Input: nums = [1,-1], k = 1
Output: [1,-1]
```

**Example 4:**

```
Input: nums = [9,11], k = 2
Output: [11]
```

**Example 5:**

```
Input: nums = [4,-2], k = 2
Output: [4]
```

​    



> 풀이 실패 과정

#### 1차시도

`window`를 실제 만들어서 매번 `max(window)`를 통해서 결과값을 얻으려 했다.

▶ 시간초과로 실패



#### 2차시도

`window`의 `max`값을 저장해두었다가 매번 빠져나가는 숫자와 새로 들어오는 숫자와 비교했다.

`max`값이 빠지는 숫자가 아니고, 새로 들어오는 숫자보다 큰 경우 \>\>\>\>  `max`값 유지

`max`값이 빠져나가는 숫자이거나, 새로들어오는 숫자가 더 큰 경우  \>\>\>\>  `max(window)` 수행

▶ 내림차순으로 정렬된 입력값의 경우 시간초과로 실패하는 문제가 발생했다. 



> 정답 코드 검색 후 이해

일단 정답 코드는 다음과 같다.

```python
from collections import deque

class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        #1 사용할 자료구조 생성
        q, res = deque(), []
        
        #2 인덱스로 순회
        for i in range(len(nums)):
            
            #3 window+1 사이즈부터 결과값넣기 시작
            if i-k >= 0:
                res.append(nums[q[0]])
                
                #4 윈도우의 가장 앞의 수가 유효한 수가 오도록 확인과 pop ★
                while q and q[0]<=i-k:
                    q.popleft()
                    
            #5 크기순으로 앞으로 쭉쭉
            while q and nums[i] > nums[q[-1]]:
                q.pop()
            
            #6 적절한 위치가 마련되었으면 삽입
            q.append(i)
            
        res.append(nums[q[0]])
        return res
```

​    

* **#0**
  * 일단 `window`가 해당하는 숫자들을 모두 가지고(저장하고) 있어야 한다는 생각을 버리자.
    * 우리가 필요한 숫자는 `window`범위 내에 있는 가장 큰 숫자이다.
    * 이 숫자(가장 큰 숫자)가 유효한 범위(`window`)내에 있을 때까지, 더 작은 숫자는 필요없다.
  * 새로 입력되는 값의 인덱스가 `k`이상이 되는 경우, 매번 `1`개씩 최대값을 넣어준다. 

* **#1**
  
  * `window`로 사용할 큐(`q`)와 결과값을 담을 `res`를 만든다.
* **#2**
  * 인덱스로 순회하는 이유는 큐(`window`)에 인덱스 값을 넣어주기 때문이다.
  * 현재 `window` 범위 내 최대값의 인덱스가 큐(`window`)의 가장 앞에 오게끔 만들 것이다.
    * 이를 위해 새로 들어오는 값은 앞쪽 값과 비교하면서 자신보다 작은 앞쪽값을 `pop` 한다.
    * **새로 들어오는 값의 인덱스가 유효한 기간**은 앞쪽의 그 어느 값보다 길기에 `pop`이 가능
* **#3**
  * 최초 `window` 생성 후 항상 수행되는 `if`문
  * `window`크기가 아닌 `window+1`크기에서 가장 큰 값을 결과값(`res`)에 넣어주는 이유
    * `window` 단계는 아직 `nums[i]`가 `window`에 입력되지 않았기에 이후 단계(`window+1`)에서 정렬된 것을 넣어준다.
    * 단, 이렇게 하는 경우, 마지막 삽입이 이뤄지지 않기에 순회 과정 종료 이후 한번 더 결과값에 넣어준다. 
    * (예시) `0,1,2,3,4,5`에서 `2,3,4,5`인덱스 순서에 결과값의 업데이트가 이뤄져야 하는데, 위의 경우 `3,4,5`에서만 업데이터가 이뤄진다.
  * 사실 위의 해석 다 필요 없고 `i-k`를 현재 (`i`번째 인덱스 값이 들어가기 전) `window`의 크기로 생각할 수 있다면 쉽게 이해할 수 있다.
* **#4**
  * 가장 큰 값(`q[0]`)이 아직 유효한지 검사(`window`에 남아있을 인덱스인지)
    * `i-k`를 사용해서 검사한다.
    * `i-k`의 두 가지 의미
      1. 현재 **`window`의 크기** (`i`를 넣기 전의 `window`)
      2. 이번 `window` 구성시 **빠져야 하는 인덱스번호**
    
  * ★가장 큰 값 뒤에 유효하지 않은 값들(인덱스가 지난 값)이 쌓여 있으면 어떻하지라는 생각

    → 예를 들면 `[2,3,4,1,1,1]`의 배열을 순회하면서 `[4,3,2,1,1,1]`이라는 큐가 만들어지면, 4는 유효하지만 3과 2는 유효하지 않은데도 같이 큐에 있는 순간이 온다.

    → 즉, 4의 비호를 받아 4가 유효한 순간까지 살아있는 것이다.

    → 그렇다면, 4가 죽으면 3이 유효하지도 않은데 결과값에 추가가 될까?

    → 그렇지 않다. 매번 가장 큰값이 죽는 경우, 다음회차에 입력될 가장 큰 값이 유효하도록 `while`문을 통해 유효한 값이 나올 때까지 `popleft()`를 해주기 때문이다.
* **#5**
  * **3번**과 **4번** 과정은 `i` 이전에 구성된 `window`를 변화시키는 과정이었다.
  * **5번**은 현재 입력대상인 값(=인덱스가 `i`인 값)을 `window`에 반영시키는 과정이다.
    * 현재 입력대상(인덱스 `i`가 가리키는 값)과 `window`에 존재하는 값들을 뒤에서부터 비교한다.
    * 비교하면서 `window`값들이 작으면 `pop()`을 한다. 
    * 더 이상 `window`에 값이 없거나 작은값이 아닌 경우 종료한다.
    * 현재 입력대상은 `window`에 존재하는 그 어떤 값보다 유효기간이 길다.
    * 따라서 위와 같은 작업이 가능하다.
  * ★ 5번과정이 `if`문 밖에 있어야 하는 이유! `k`개가 만들어지기 전부터 정렬을 시켜놔야 `if`문 수행시 제대로된 값이 입력된다.(`window`내에서 가장 큰 값이 입력된다)
  * `if`문은 결과값에 입력되는 순간부터 작동하는 것으로 결과값입력과 다음 결과값을 위한 유효숫자 정검의 기능을 담당한다.
* **#6**
  
  * 이제 현재 대상값(인덱스 `i`가 가리키는 값)을 `window`에 넣는다. 