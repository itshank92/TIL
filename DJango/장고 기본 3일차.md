3일차,4일차



# UPDATE



UPDATE는 두가지 단계로 구성된다.

1) 데이터를 읽어와서 수정할 수 있는 페이지 만들기(READ)

2) 수정한 데이터를 다시 저장하기(CREATE)

UPDATE는 기본적으로 READ와 CREATE 두 단계로 구성된다.





# POST

post로 보내면 form클래스의 객체로 데이터가 전송된다.

get으로 보내면 그냥 url뒤에 params로 데이터가 전송된다.



데이터를 입력받을 때는 get으로 보낼것이고

받은 데이터를 처리할 때는 post로 보낼 것이다.





Form의 필드(column)들

▶ HTML Form의 필드(column)들을 파이썬 클래스화

(참고)

Model의 필드(column)들

▶ DB의 필드(column)을 파이썬 클래스화



> POST로 온 request 읽기

request.Post.get('name의값')





> Restful URL

Restful  방식으로 URL을 만들것이다. 

URL을 여러개로 나눠서 각 기능(GET,POST등)을 나누는게 아니라, 하나의 URL에서 기능별로 다른 페이지를 보여주도록 만드는 것



> CSRF(Cross-site request forgery)

웹사이트에 대한 공격 중 하나

공격에 대한 전제 조건

1. 공격 대상 서비스 웹사이트에 희생자가 로그인 상태
2. 희생자가 해커가 만든 피싱 사이트에 접속 상태

위 상황은 발생하기 그리 어려운 상황이 아니다.

예를들면 페이스북에 자동로그인 설정한 상태에서 음란광고로 피싱사이트가 열릴 수 있다.

피싱사이트에서  form의 action 주소가 facebook/내게시판이면 facebook에 희생자의 이름으로 글을 적을 수 있다. 





> 장고에서의 CSRF 인증 태그

이번에 보낼 FORM 데이터는 현재 사이트에서 만들어진 것으로 인증하는 것

`{% csrf_token %}`

▶ 토큰을 form 데이터에 포함해서 전달함으로서 보안을 인증해준다.





# Redirect



`from django.shortcut import redirect`



다시 이동할 url을 이동해주는것(다시 해당 url의 views.메소드로 이동할 것이다)





> HTTP Status Code(상태코드)

앞의 숫자만 보면 된다. (2,3,4,5)

#### 2로 시작하는 경우 올바르게 된 경우를 의미한다.

200은 요청이 잘 처리되었음을 의미한다.

#### 3으로 시작하는 경우 다른 주소로 접근해야 하는 경우를 의미한다.

301은 처음 입력한 url이 올바르지 않아서 올바른 url을 찾아서 올바른 url로 요청을 보내는 것을 의미한다. 
(301은 잘못된 주소를 올바른 주소로 redirect했다는 의미의 상태코드이다.)

301이 나온 후 제대로 된 사이트에 접속했다면 앞서 배운 200이 나타난다.

#### 4로 시작하는 경우 사용자의 요청 사이드에서의 에러발생을 의미한다.

401: unAuthorized 현재 요청을 보낸 사용자가 해당 url에 들어갈 권한이 없을 때 발생하는 에러

403: csrf token이 없을 때 발생하는 에러(받은 데이터의 유효성 보장이 안되있을 때)

404: 현재 요청한 url 주소가 서버에 없을 때

#### 5로 시작하는 경우 서버 사이드에서의 에러발생을 의미한다.







# (장고의) 폼

참고: https://tutorial.djangogirls.org/ko/django_forms/

참고2: https://wayhome25.github.io/django/2017/05/06/django-form/





> 장고의 폼은 왜 태어났을까?

그동안 우리는 HTML의 form태그를 직접 하드 코딩해서 사용자의 입력값을 받아왔었다

예를 들면 게시판의 게시글을 올리는 페이지를 작성할 때 직접 `<from action...>`으로 시작하는 코드를 작성했었다.

근데 한번은 괜찮은데 이런 게시판이 여러개 있는 사이트인 경우 각 html 페이지에서 이 `form` 코드를 복사해서 계속 붙여넣어줘야 할까?

이 일을 쉽게 해주는 것이 바로 장고의 폼(form)이다.
(사실 장고의 폼은 form tag 코드를 쉽게 처리해주는것 외에도 다른 장점도 매우 많다.)

장고에서는 입력값을 받는 form tag 코드를 하나의 폼 클래스로 만들어서 관리한다.

이제 이 일을 좀 더 쉽게 하기 위해 form도 하나의 클래스로 만들어서 여기저기서 불러와서 사용할 수 있게 만들자.



> 장고의 폼은 어떻게 만들까?

폼도 폼만의 forms.py라는 파일에서 관리한다.

폼의 목적은 사용자의 입력값을 쉽게 받고 해당 입력값으로 모델 테이블에 쉽게 저장하기 위함이다.

```PYTHON
from django import forms

from .models import Post  ## form과 연동될 모델 클래스를 불러온다.

class PostForm(forms.ModelForm):

    class Meta:
        model = Post
        fields = ('title', 'text',)
```



> 장고의 폼의 종류는 두가지가 있단다.

폼에는 종류가 2가지가 있다. 

* 모델폼
  * **우리가 만들었던 모델에 맞는 폼**이다.
  * **즉 우리가 만들었던 모델의 필드(칼럼)에 맞는 입력 폼을 만들어 주는 것**이다.
  * 우리가 정성들여 만들었던 모델 클래스를 그냥 import해와서 해당 폼의 model 속성의 값으로 주면 된다.
  * 단 주의해야 할 것은 class 내부에서 `Meta`라는 이름의 자식 class를 만들고 이 `Meta`의 속성값으로 model을 입력해야한다는 것이다.
  * 모델 입력후에는 field라는 속성값에 우리가 만든 모델의 field를 문자열로 넣어준다.
  * [요약] **모델폼**은 **모델과 필드를 지정**만해주면 **장고가 알아서 만들어주는 폼 양식**이다.

```python
from django import forms

from .models import Acrticle  ## form과 연동될 모델 클래스를 불러온다.

class PostForm(forms.ModelForm): # forms의 ModelForm을 이용한다.

    class Meta:
        model = Acrticle
        fields = ('title', 'text',)
```





* (그냥) 폼
  * 모델폼과 다르게 뭐 어디서 정보를 가져올 것 없이 사용자가 직접 만드는 form 클래스다.
  * 직접 필드를 정의해야한다.(데이터 타입 등등)

(그냥) 폼의 코드는 아래와 같다.

```python
from django import forms

class NormalForm(forms.Form): # forms의 Form을 이용한다.
    title = forms.CharField()
    content=forms.CharField(widget=forms.Textarea)
    
```





> 장고 폼 사용하기

1. #### 장고폼을 views의 함수에서 불러와서 context에 넣어서 html페이지로 넘겨준다.

* 장고 폼 클래스들을 저장한 forms.py에서 우리가 사용할 폼 클래스를 불러오는 것으로 시작한다.

  `from .forms import PostForm`

* 불러온 폼 모듈을 사용하여 객체를 만들어서 변수로 지정한다. 그리고 해당 변수를 context에 넣어서 render 의 인자로 보낸다.

  ```python
  def post_new(request):
      form = PostForm()
      context = {
          'form':form
      }
      return render(request, 'main/index.html', context)
  ```

  

2. #### html 파일에서 받은 폼을 가지고 입력란을 쉽게 만든다.

* 앞서 받은 폼을 가지고 입력란을 쉽게 만들 수 있다.

* 예시 코드는 아래와 같다

  ```python
  ...
  <form method:'POST' class='post-form'>
      {% csrf_token %}
      {{ form.as_p }}
      <button type='submit'>Save</button>
  </form>
  ...
  ```

  

* 일단 폼을 불러와도 form 태그는 만들어줘야 한다.
  
  * 왜냐면 우리가 만든 장고의 폼은 어디로 가야하는지 url 정보가 없기 때문이다.
* form 태그 아래에서 form.as_p라는 DTL 태그를 사용하면 장고가 장고 폼을 사용해서 입력란을 만들어준다.



3. #### 해당 페이지에서 사용자가 입력한 값이 다시 POST로 전달되면 우리는 전달받은 장고 폼을 가지고 데이터를 추출해야 한다.

   * `<form action = 'POST'...>`로 전달한 (입력된) 장고 폼은 request.POST에 저장이 된다.

   * request.POST를 인자로 우리가 만들었던 장고 폼의 인자로 넣어서 새로운 장고폼 객체를 만든다.

     `form = PostForm(request.POST)`

   * 이전과 다르게 이번에 만든 장고폼 객체는 인자 즉 입력값이 다 채워진 객체다. 

     * 이전의 장고 폼 객체 = 입력값이 없던 빈 장고폼 ▶ html 페이지에서 입력란 만들기로 사용
     * 지금 장고 폼 객체 = 입력값이 있는 채워진 장고폼 ▶ 데이터 베이스 테이블에 데이터 입력하기 위해 사용

   

4. #### 우리가 (입력받은 데이터를 넣어서 만든) 장고폼 객체가 유효한지 판단한다.

   * 이때 유효하다는 것은 입력 데이터가 제대로 입력되었는지 확인하는 작업이다.

     ```python
     import timezone
     
     ...
     
     #1
     if form.is_valid():
       	#2  
         post = form.save(commit=False)
         #3
         post.user = request.user
         #4
         post.published_date = timezone.now()
         #5
         post.save()
         
     ```

     ​       

     * **#1**
       * 폼 객체는 `.is_valid()` 메소드로 유효성을 검사한다.
     * **#2**
       * 폼 객체의 `.save()` 는 두 가지 기능이 있다. 
         1. 자신에게 있는 입력데이터 값을 이용해서 해당 **폼 객체와 연결된 모델 객체를 생성**한다.
            * 자신의 meta 데이터에 있는 모델의 객체를 생성하는데 입력데이터를 이용해서 field를 채운다. 
         2. 모델 객체 생성과 동시에 해당 `모델객체.save()`도 동시에 수행한다.
            * 하지만 만들어진 모델 객체에 입력값이 없는 field가 있는 경우 `.save()` 수행시 오류가 발생한다. 
            * 따라서 `폼객체.save()`의 두번째 기능인`모델객체.save()`를 꺼주는 것이 필요하다.
            * 이 기능을 꺼주기 위해서  `commit=False`를 인자로 넣어준다.
            * `commit`은 자동으로 모델객체 `.save()`를 해준다는 의미이다. 
     * **#3**
       * request에 담겨진 user 정보를 모델객체의 user 속성값으로 넣어준다.
     * **#4**
       * 현재 시간(timezone.now())를 불러와서 모델객체의 published_date 속성값으로 넣어준다.
     * **#5**
       * 모델객체의 속성(field)이 모두 채워졌다면 저장한다. 





----

# include html



include: template 내에서 다른 template을 불러와서 넣는 태그

※ 주의: 지금 배우는 include는 DTL 태그이고 전에 path 설정에서 배웠던 include는 모듈의 메소드다.(전혀 상관없는 것)



사용방법

template내에서 다른 template을 불러와서 해당 내용을 넣어주고 싶을 때 다음과 같이 사용한다.

`{% include "불러오려는template파일" %}`

(예시: `{% include "navbar.html" %}`)



> 사용하는 이유

템플릿의 특정 영역을 중복, 반복해서 사용할 경우에 유용하다. 

▶ 반복되는 경우 따로 분리된 html파일로 만들어서 독립적인 template으로 관리하자.





# 대량의 테스트 데이터 만들기 ▶ 장고셸을 사용하여

대량의 테스트 데이터를 만드는 가장 좋은 방법은 장고셸을 사용하는 것이다.



1. 장고셸 실행

   ```python
   (mysite) c:\projects\mysite>python manage.py shell
   Python 3.8.2 (tags/v3.8.2:7b3ab59, Feb 25 2020, 22:45:29) [MSC v.1916 32 bit (Intel)] on win32
   Type "help", "copyright", "credits" or "license" for more information.
   (InteractiveConsole)
   >>>
   ```

2. 더미 데이터를 채울 <u>모델</u>과 <u>채울 때 사용할 데이터를 위한 모듈</u> 가져오기

   ```python
   >>> from pybo.models import Question
   >>> from django.utils import timezone
   ```

3. `for`문을 사용해서 300개의 테스트 데이터를 생성하자.

   ```python
   >>> for i in range(300):
   ...     q = Question(subject='테스트 데이터입니다:[%03d]' % i, content='내용무', create_date=timezone.now())
   ...     q.save()
   ...
   >>>  
   ```

   

