### 카운팅정렬

> 설명

* 집합에 각 항목이 몇 개씩 있는지 세는 작업을 수행을 통해 오름차순 정렬을 선형 시간에 수행하는 효율적인 알고리즘

​     



> 제한사항

* 정수나 정수로 표현할 수 있는 자료에 대해서만 적용이 가능하다. 
  * 이유: 카운팅 정렬은 각 항목이 몇 번 존재하는지 기록하는 것이기 때문이다.
* 카운트를 위한 충분한 공간을 할당하기 위해서는 집합 내의 가장 큰 정수를 알아야 한다.

​    



> 시간복잡도

* O(n+k): n은 리스트 길이, k는 정수의 최대값

​     



> 예시

* 입력값:  `input_list = [0,4,1,3,1,2,4,1]`

* 작동과정

  1. 가장 큰 정수 파악해서 해당 길이+1의 초기값 가진 리스트 생성(인덱싱 편하게 하기 위해 +1)

     ```python
     count = [0] * (len(input_list)+1)
     
     #=> [0,0,0,0,0]
     ```

  2. 앞에서 읽어가면서 각각의 값을 인덱스로 사용해서 `count`를 업데이트한다.

     ```python
     for num in input_list:
         count[num] += 1
         
     #=> count = [1,3,1,1,2]
     ```

  3. `count` 요소를 돌면서 각 요소를 이전의 누적합으로 바꾼다.

     ```python
     for idx in range(1,len(count)):
         count[idx] += count[idx]-1
     
     #=> count = [1,4,5,6,8]
     ```

  4. 최종 결과 리스트를 만들기 위해 최초 입력값의 길이와 같은 빈 리스트를 생성한다.

     ```python
     result = [0] * len(input_list)
     ```

     

  5. 최초의 입력데이터를 뒤에서부터 순회하면서, 각 숫자를 인덱스로 사용해서 `count`에서 값을 조회한다. 
     `result` 리스트의`조회한 값 - 1`의 위치에 해당 값을 넣는다.

     ```python
     for num in input_list[::-1]:
     	count[num] -= 1
         result[count[num]] = num
         
     # result = [0,1,1,1,2,3,4,4]
     ```

​    

> 뒤에서부터 정렬하는 것의 장점

* 뒤에서부터 정렬하는 것의 최대 장점은 '**안정정렬**'이라는 것이다. 

* **안정정렬**이란?
  * 동일한 값이 존재하는 경우 입력 데이터의 순서를 유지하면서 정렬이 가능하다.
  * 위의 경우, 가장 마지막에 입력된 1은 result의 인덱스 3번에, 두번째로 입력된 1은 인덱스 2번에, 첫번째로 입력된 1은 인덱스 1번에 위치하게 된다. (=최초 입력 순서 유지)
  * **안정정렬**을 위해서 뒤에서부터 순회하는 것이다. 