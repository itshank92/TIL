# 점프게임

출처: https://leetcode.com/problems/jump-game  55번





> 생각

* 그리디 알고리즘은 매번 최선의 선택을 하는 것인데, 앞에서부터 선택을 하기에는 무엇이 최선의 선택인지 알 수 없다.
  * 즉, 가장 마지막에 도착하는 루트에 대해 아는게 없기때문에 무엇이 최선의 선택인지 알 수 없는 것이다.
  * 따라서 그리디 알고리즘을 취할려면 뒤에서부터 접근한다.     



* 뒤에서부터 앞으로 탐색을 하면서 도착점에 도착할 수 있는 지점을 찾는다.
  * 해당 지점을 찾으면 해당 지점을 도착지로 설정하고 또 다시 앞으로 가면서 가능한 지점을 찾는다.
  * 이게 가능한 이유는, 도착지부터 앞으로 가면서 가능한 지점(A)을 찾는다면 그 앞쪽에 한 번에 도착지로 갈 수 있는 지점(B)이 또 있는 경우, 해당 지점(B)은 100% 현재 지점(A)까지 갈 수 있는 곳이기 때문이다.    



* 인덱스 0번까지 탐색을 했다면, 탐색을 종료하고, 현재 도착지로 설정된 곳이 인덱스 0번 지점인지 아닌지 확인한다.
  * 현재 도착지가 0번 지점이어야지 출발지부터 끝까지 점프할 수 있는 것을 의미한다.    



* ★ 주의 ★ 입력값의 범위를 확인해서 위의 코드가 작동하지 못하는 범위(여기서는 입력값 길이가 1인 경우)를 전처리 해준다.



>  코드

```python
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        # 입력값 길이가 1인 경우 처리
        if len(nums) == 1:
            return True

        # 도착지 설정
        target = len(nums)-1
        # 포인터 설정
        idx = len(nums)-2
        # 시작점까지 탐색
        while idx >= 0:
            # 현재 탐색지점 + 점프횟수가 도착지보다 크거나 같은 경우
            if nums[idx] + idx >= target:
                # 도착지 업데이트(현재지점으로)
                target = idx
            # 탐색 지점 한 칸 앞으로 이동
            idx -= 1
        
        # 탐색종료 후 도착지 확인
        if target == 0:
            return True
        return False
```

