# 모델, 뷰, 템플릿 설명

#### 장고를 구성하는 3가지 요소



## 모델

파이썬을 사용해서 DB에 저장할 데이터 셋의 형식을 만들어 주는 것

쉽게 말해서 DB에 생성할 테이블의 metadata를 파이썬의 모델 클래스로 만들어서 사용한다.

모델 클래스를 사용해서 테이블을 생성하고 해당 테이블에 데이터를 넣고 삭제하고 등등을 수행한다.



> 기초 공사

* 모델
  * 모델과 데이터 베이스는 다르다
  * 장고는 모델을 통해 데이터 베이스에 접속하고 관리된다
  * 일반적으로 **각각의 모델은 하나의 데이터 베이스 테이블에 매핑**된다.     



* 데이터 베이스
  * 체계화된 데이터의 모임    



* 쿼리
  * 데이터를 조회하기 위한 명령어
  * 조건에 맞는 데이터를 추출하거나 조작하는 명령어  

> 데이터 베이스의 기본 구조

* 스키마(Schema)

  * 데이터베이스에서 자료의 구조, 표현방법, 관계 등을 정의한 구조

    ▶ **데이터 베이스의 전반적인 구조를 명세한 MetaData**가 바로 스키마(Schema)다.    



* 테이블
  * 필드(Field) = 컬럼(Column) = 속성
  * 레코드(Record) = 행(Row) = 튜플    



> (DB) 테이블의 규칙

* [열 규칙] 각각의 열에는 고유한 데이터 형식이 있다.

  ▶ 그 데이터 형식에 맞는 데이터만 입력가능하다.    



* [행 규칙] 테이블의 데이터는 행에 저장된다.

  * 즉, User라는 테이블에 4명의 고객정보가 저장되어 있다면 Row는 4줄이다.

    (각각의 고객은 하나의 줄(Row)로 저장됨)



* [PK 규칙] PK (Primary Key)는 반드시 존재해야 하는 필드(칼럼)다.

  * PK는 각 레코드(행)의 고유값을 담는 필드(칼럼)다.  

  * PK는 반드시 설정하여야 하고, 데이터 베이스 관리 및 관계 설정시 매우 중요하게 활용된다.

    ▶ 각 행은 각각 고유한 객체에 대한 정보이고 이를 명확하게 구분해주기 위해 각 행마다 유니크한 값을 주는 것이 PK의 역할이다.    



> 모델은 무엇인가

* **웹어플리케인션의 데이터를 구조화하고 조작하기 위한 도구**
* 모델을 통해서 데이터 베이스의 **데이터들을 조작**한다.       





> ORM_모델을 통해 데이터 베이스를 조작하는 방식

* ORM은 객체 지향 프로그래밍 언어를 사용해서 **호환되지 않는 유형의 시스템(ex_Django - SQL)간에 데이터를 교환하는 방식**이다. 

* 쉽게 말해 Django로 만든 프로젝트(웹사이트)에서 DB를 연결하고 DB를 통제하는데 사용하는 방식이 ORM이다.

* 좀 더 자세히 설명하자면 **Django의 Python 명령어를 ORM으로 번역하고 이를 SQL로 번역해서 DB를 관리**한다.

  [ `Django의 Python 명령문` → `ORM`(이후 내부적으로 SQL문으로 변경됨) → `DB관리` ]

* **Object Relational Mapping**



> ORM의 장점과 단점

* 장점

  * SQL을 잘 알지 못해도 DB의 조작이 가능하다.

  * SQL의 절차적 접근이 아닌 객체 지향적 접근으로 인해 높은 생산성이 보장된다.

    (기존의 SQL문이 가진 생산성을 뛰어넘을 수 있다)

* 단점
  * ORM이 모든 SQL문을 대체하는 것이 아니므로 특정 서비스의 경우 SQL문으로 구현해야 한다.

* 결과
  * 현재 웹 프레임워크의 가장 중요한 이슈는 **웹개발의 생산 속도**를 높이는 것으로 ORM은 이러한 환경에 있어 매우 중요한 기능이다.→ 단점이 있어도 장점이 너무 큰 ORM

​     

[ORM의 사용 목적]

**"우리는 DB를 객체(Object)로 조작하기 위해 ORM을 사용한다."**    

​      



> Model을 생성

모델은 app 하위 요소로 app 디렉토리의 `models.py`에 작성한다.

```python
from django.db import models

class Article(models.Model):
    # 각 변수는 칼럼으로 들어간다(Primary Key(PK)칼럼의 경우 자동으로 입력된다)
    # 각 변수(칼럼)의 데이터 유형은 models 모듈의 데이터 유형 클래스를 사용해서 지정한다.
    # CharField는 제한이 있는 문자열로 max_length가 필수 인자이다!(없으면 오류)
    title = models.CharField(max_length=10) 
    content = models.TextField()
    # 데이터의 작성일과 수정일 칼럼 추가
    # 자동으로 입력값이 넣어지도록 하는 인자 사용(auto_now_add=True)
    # 자동으로 입력값이 넣어지도록 하는 인자 사용(auto_now=True)
    # auto_now: 자동으로 객체가 (매번) 저장될 때마다 해당 field를 수정한다.
    # auto_now_add: 객체가 처음 저장될 때만 해당 field를 수정하고 이후에는 수정하지 않는다.
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
```

​     



## 뷰

* 뷰는 사용자가 요청한 URL에 걸맞는 화면을 보여주기 위해 **Model의 데이터**와 **Template의 화면**을 **연결시켜주는 역할**을 수행한다.

* 뷰 파일(`views.py`)은 app에 존재한다. (프로젝트에 있는게 아니다)

* 뷰 파일에 작성하는 함수의 첫번째 인자는 반드시 `request`다.
  * 뷰는 결국 사용자의 요청에 따라 보여주고자 하는 것을 작성하는 것이기에 기본 전제 입력값은 사용자의 요청이다.



## 템플릿

​      

> View 함수의 끝단에서 템플릿 파일이 반환(`return`)된다.

* **View**에서 **Model**을 통한 데이터 처리가 끝나면 적절한 **Template**을 반환한다.
* 이 때 **render**라는 함수의 인자로 **Template**파일이 들어가서 반환된다. 
* **템플릿을 불러오는 함수**인 `render`함수의 첫번째 인자는 `request`이다.
  * `request`(사용자의 요청)이 있어야 해당 Template을 누구에게 보여줄지 알 수 있다.
* `render`의 인자는 다음과 같다(순서 주의)
  * `render(request, 템플릿으로 불러올 html 파일경로, 템플릿에 전달할 데이터)`
  * 템플릿에 전달할 데이터는 `key:value` 형태로 전달한다.(아니면 `딕셔너리`를 전달하면 된다)
  * 전달받은 데이터는 템플릿 내에서 태그를 사용하여 접근 및 사용이 가능하다.      

​       



> 템플릿은 어디에 만들어야 하는가

* 기본적으로 템플릿은 `Application` 디렉토리 안에 작성한다.
  * `Application` 디렉토리에 `templates` 폴더를 만들고 해당 폴더 안에 작성해야 한다.
* 장고에서는 `Application` 디렉토리 안에 있는 `templates`폴더 안의 템플릿 파일들을 모두 하나의 폴더에 존재하는 것처럼 인식한다.
  * 즉 `Application_01` 디렉토리의 `templates`폴더 안의 `index.html`도, `Application_02` 디렉토리의 `templates`폴더 안의 `index.html`도, **장고에서는 하나의 공간에 존재하는 것으로 본다**.
    * 따라서 **같은 이름을 가진 템플릿 파일의 경우 겹치는 문제**가 생긴다.
    * 이를 방지하기 위해, 각 `Application` 디렉토리의 `templates` 폴더안에 해당 `Application`이름의 폴더를 만들고, 해당 폴더 안에 템플릿 파일을 만드는게 좋다.
    * (구조) `Project` > `Application` > `templates` > `application` > `template.html`
* 하지만 `Application`들이 공통으로 사용하는 템플릿 파일같은 경우 프로젝트 디렉토리에 만드는 것이 좋다.
  * 프로젝트 디렉토리에 `templates` 폴더를 만들고 공통으로 사용하는 템플릿 파일을 저장한다.



| **장고는 App 하위에 있는 templates 디렉터리를 자동으로 템플릿 디렉터리로 인식한다** |
| ------------------------------------------------------------ |
| 장고는 프로젝트 디렉터리 외에도 특정 App 디렉터리 하위에 있는 `templates`라는 이름의 디렉터리를 자동으로 템플릿 디렉터리로 인식한다. <br />예를 들어 `pybo`라는 앱이 있다고 할 때, `pybo` 디렉터리 밑의 `templates` 디렉터리는 별다른 설정을 하지 않아도 템플릿 디렉터리로 인식된다.<br /><br />`C:\projects\mysite\pybo\templates`<br /><br />하지만 이 방법으로 템플릿을 관리하는 것은 권장되지 않는다. 왜냐하면 하나의 사이트에서 **여러 앱을 사용할 때 여러 앱의 화면을 구성하는 템플릿은 한 디렉터리에 모아 관리하는 편이 여러모로 좋기 때문**이다. 예를 들어 여러 앱이 공통으로 사용하는 공통 템플릿을 어디에 저장해야 할지 생각해 보면 왜 이런 방법을 선호하는지 쉽게 이해될 것이다.<br /><br />● 공통 템플릿 디렉터리 ▶ `C:/projects/mysite/templatespybo` <br />● 앱 템플릿 디렉터리▶`C:/projects/mysite/templates/pybo` |

​        

​     

> DTL (Django Template Language)

* 장고에서 템플릿 내부에서 사용하는 템플릿 언어다.

* 파이썬처럼 일부 파이썬 문법을 사용할 수 있지만 DTL을 파이썬으로 실행시킬 수 있는 것은 아니다.

* 템플릿은 장고의 태그를 추가로 사용할 수 있는 HTML 파일이라 생각하면 된다.

  * html 문법내에서 장고의 태그를 사용하기 위한 문법이 바로 DTL이다.     

​     



> (장고의) 탬플릿 태그(Tag)

* 템플릿 태그는 {% 와 %}로 둘러싸인 문장을 말한다. 
* 다음 표에 정리한 템플릿 태그의 의미를 살펴보면 파이썬 문법과 크게 다르지 않음을 알 수 있다. 
* 템플릿 태그는 따로 문법을 설명하지 않고 그때그때 필요할 때마다 설명하겠다.

|               템플릿 태그               |                            의미                            |
| :-------------------------------------: | :--------------------------------------------------------: |
|        `{% if question_list %}`         |                   question_list가 있다면                   |
|  `{% for question in question_list %}`  |    question_list를 반복하며 순차적으로 question에 대입     |
|           `{{ question.id }}`           |       for 문에 의해 대입된 question 객체의 `id` 출력       |
|        `{{ question.subject }}`         |    `for` 문에 의해 대입된 question 객체의 subject 출력     |
| (`for`태그 아래에 사용됨) `{% empty %}` | `for`태그가 순회하는 대상에 어떠한 요소도 없는 경우 실행됨 |

​     



### 템플릿 태그! 3가지 유형만 정리하면 끝!

장고의 템플릿 태그에는 **분기** ,  **반복** , **객체 출력**이라는 3가지 대표적인 유형만 알면 된다. 

1. **분기 템플릿 태그**는 파이썬의 `if` 문과 같은 기능을 수행하는 태그다. 
   차이점은 `if` 문이 끝나는 부분에 `{% endif %}`를 사용한다는 것이다. 

```python
{% if 조건문1 %}
    <p>조건문1이 참인 경우 실행됨</p>
    
{% elif 조건문2 %}
    <p>조건문1이 참인 경우 실행됨</p>
    
{% else %}
    <p>조건문1, 2에 모두 참이 아닌 경우 실행됨</p>
    
{% endif %}  
```

​       

2. **반복 템플릿 태그**는 파이썬의 `for` 문과 같은 기능을 수행하는 태그다. 
   차이점은 분기태그와 마찬가지로 마지막은 `{% endfor %}`로 닫아야 한다는 것이다.

```python
{% for item in list %}
    <p>순서: {{ forloop.counter }} </p>
    <p>{{ item }}</p>
{% endfor %}
```



※ 또한 반복 템플릿 안에서는 `forloop` 객체를 사용할 수도 있다. `forloop` 객체는 반복 중 유용한 값을 제공한다.

| forloop 객체 속성  |                 설명                  |
| :----------------: | :-----------------------------------: |
| `forloop.counter`  | `for` 문의 순서로 숫자  `1`부터 표시  |
| `forloop.counter0` |  `for` 문의 순서로 숫자 `0`부터 표시  |
|  `forloop.first`   | `for` 문의 첫 번째 순서인 경우 `True` |
|   `forloop.last`   | `for` 문의 마지막 순서인 경우 `True`  |

​        

3. **객체 출력 템플릿 태그**는 다음과 같다. 객체에 속성(attribute)이 있는 경우 파이썬과 동일한 방법으로 점(`.`) 연산자를 사용한다.

```
{{ question }}
{{ question.id }}
{{ question.subject }}
```

​       



> 부모 템플릿과 자식 템플릿

* **부모 템플릿**에서는 `{% block %}`와 `{% endblock%}` 사이에 자식 템플릿이 쓸 수 있는 공간을 만든다.
  * `{% block %}`에는 이름을 지정할 수 있다.
    * (예시) `{% block name %}`
  * 이렇게 이름을 지정하면 자식 템플릿에서 원하는 `block`을 선택에서 입력할 수 있다. 

* **자식 템플릿**에서는 `{% extends '부모 템플릿 경로' %}`로 상속받음을 선언하고 `{% block name %}`과 `{% endblock %}`사이에 넣을 내용을 작성한다.
  * **★주의★** `{% extends %}`를 사용할 때는 반드시 **템플릿 최상단에 작성**되어야 한다.     

​    

 