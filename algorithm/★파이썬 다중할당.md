# 파이썬 다중할당

​    

**다중할당을 실험해보기 전에 그냥 할당에 대해서 이해해보자**



### 1.변수와 객체

* 변수는 할당 연산자의 왼쪽에 있는지 혹은 오른쪽에 있는지에 따라서변수명이 되기도하고 객체가 되기도한다.
  * 왼쪽에 있는 경우(=객체를 할당받는 경우) ▶ 변수는 변수명이 된다. 
  * 오른쪽에 있는 경우(=할당의 재료로 쓰이는 경우) ▶ 변수는 객체가 된다.      



* 변수명과 객체
  * 변수명: 빈 이름 (이전에 해당 변수에 할당받은 객체와는 아무 관계 없음)
  * 객체: 실제 존재하는 데이터

```python
# 변수 a,b는 =의 왼쪽에 있기에 변수명이 된다.
# a,b는 각각 1,2라는 객체를 할당받는다.
a,b = 1,2

# =의 왼쪽에 있는 b는 변수명이 된다.
# =의 오른쪽에 있는 a는 객체가 된다.
# 변수명(빈이름) b에 객체 a가 할당된다. 
# ※ 이 경우 기존에 b에 할당 되었던 객체(2)는 사라진다. 
b = a

# =의 왼쪽에 있는 a는 변수명이 된다.
# 3은 당연히 객체이므로 변수명 a에 3이 할당된다.
# ※ 이 경우 기존에 a에 할당되었던 객체(1)은 b만 가리키게 된다.
a = 3
```

​      

★ [결론] ★ 

**변수는 할당 연산자의 왼쪽에 있으면 빈 변수명으로 사용되고 오른쪽에 있으면 객체로 사용된다.**      

​      



**이제 다중할당에 대해서 알아보자**



### 2. 다중할당

* 다중할당을 사용하는 주된 경우는 **클래스의 속성**을 변경해줄 때이다.
* **클래스의 속성**은 일반적인 변수와는 다른 특성이 하나가 있다.
  * **클래스의 속성**은 존재하는 객체에 해단 변수라는 것이다. 
  * 즉 `a`나 `b`와 같은 일반적인 변수와 달리 **클래스의 속성**은 `어떤 객체`가 존재하고 그 객체에 대한 변수다.



* 다중할당의 규칙은 다음과 같다.
  * 일반 할당과 마찬가지로 왼쪽에 있는 것은 변수명, 오른쪽에 있는 것은 객체다.
  * **오른쪽에 오는 객체들은 코드를 실행시키는 순간 값이 변하지 않는다.**
  * **즉 새롭게 왼쪽에서 할당된 것이 적용되지 않는다.** 

```python
# class node:
#   def __init__(self,val=0,next=None,feature=None):
#     self.val = val
#     self.next = next


# 할당 복습
node1 = node(1)
# >> node1이라는 빈 변수명에 node(1)이라는 객체를 할당
node1.next = node(2)
# >> node1.next라는 빈 변수명에 node(2)라는 객체를 할당
node1.next.next = node(3)
# >> node1.next.next라는 빈 변수명에 node(3)이라는 객체를 할당

## 위에서 사용한 .next가 붙은 변수명이 
## 기존의 일반적인 변수명과 다른점(다른특성)은
## 해당 변수명은 클래스의 속성으로 
## .앞에 유효한 객체가 존재해야 한다는 점이 다르다.


# 할당 복습2
rev = node(4)
# >> rev라는 빈 변수명에 node(4)라는 객체를 할당
rev.next = node(5)
# >> rev.next라는 빈 변수명에 node(5)라는 객체를 할당


# 다중 할당
# 할당과 마찬가지로 왼쪽은 빈 변수명, 오른쪽은 객체

# 1            2         3
node1.next,   rev,   rev.next,  =  node(6),   node1.next,   node1.next.next
# 1. node1.next에 node(6)이 할당된다. 
#    ▶ node1.next는 빈 변수명이다.

# 2. rev에 node1.next가 가리키는 객체가 할당된다.
#    ▶ 이때 node1.next 객체는 방금 1번에서 할당된 객체가 아니라 해당 코드 실행전에 
#       입력된 객체(node(2))다.
#    ▶ 이 상황에서 rev라는 변수는 node1.next의 객체를 가리키게 된다.

# 3. 그리고 rev.next에 node1.next.next가 가리키는 객체가 할당된다.
#    ▶ 이때의 rev는 1에서 바뀐 node1.next 객체이다. 



print(node1.next.val)
print(rev.val)
print(rev.next.val)
#print(node1.next.next.val)   >> Nonetype에는 val이 없다는 에러 발생


## 결과값
# 6
# 2
# 3
```

​     

다중할당 연습

```python
node1 = node(1)
node1.next = node(2)
node1.next.next = node(3)

# rev: 4 → 5
rev = node(4)
rev.next = node(5)

# 다중할당
rev.next , rev = node1, rev.next
# rev.next에 (코드 입력전 상태의)node1이 할당된다. 이때 rev는 4-1-2-3이 된다.
# rev에 (코드 입력전 상태의)rev.next가 할당된다. 이때 rev는 node(5)가 된다.


while rev:
  print(rev.val)
  rev = rev.next
    
# 결과값
# 5
```

