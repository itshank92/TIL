# 카운팅 정렬



> 카운팅 정렬의 기본

카운팅 정렬은 정렬 대상의 수의 범위가 한정적일 때 사용한다.

기본적인 카운팅 정렬은 다음과 같은 방식으로 작동한다.

1. **정렬 대상이 되는 숫자들의 범위 (`0 ~ 최대값`) 크기의 카운팅 배열을 만든다**. (초기값은 `0`)
2. 정렬 대상이 되는 리스트와 **같은 길이를 가진 리스트**를 만든다. (정렬 결과를 담을 리스트)
3. 정렬 대상이 되는 **배열을 순회하면서 각 값을 인덱스로 사용해서 카운팅 배열에 `+1`**을 한다.
   * 배열의 각 값은 카운팅 배열의 인덱스로 사용되어 등장할 때마다 해당 위치에 `+1`을 해준다.
   * 다시 말해 **카운팅 배열은 정렬 대상 배열 값들의 등장횟수를 기록한 배열**이다.
4. 2번이 끝난후, **카운팅 배열을 앞에서부터 순회하면서 각 값들을 누적합으로 바꾼다**.
   * `counting_arr[i] += counting_arr[i-1]`
   * 누적합으로 바꾸는 이유는 **누적합을 최종 배열의 인덱스로 사용할 수 있기 때문**이다.
5. **원래의 배열을 뒤에서부터 순회**하면서 각 값을 인덱스로 사용해서 카운팅 배열의 값으로 접근한다.
   * 카운팅 배열의 값은 누적합으로 여기에 `-1`을 하면 최종 리스트에서 해당 값이 위치할 인덱스가 된다.  (`누적합-1` = 해당 값이 최종 리스트에 위치할 인덱스)
   * 해당 위치에 해당 값을 위치시킨다음 누적합의 값을 `-1`해준다.
   * ★ **뒤에서부터 탐색하는 이유는 동일한 값의 경우 원래의 순서를 유지해주기 위함**이다.
     (카운팅 정렬은 안정정렬(stable sort)이다)

​      



> 기본적인 카운팅 정렬 코드 구현

```python
# 코드의 전제: 배열의 값은 1부터 20사이의 값으로 구성된다.
# ▶ 이러한 조건이 있어야 카운팅 배열 사용가능(최대값이 무엇인지 알아야 사용가능)
arr = [8,19,2,6,7,1,15,13,8,2]


def counting_sort(arr):
  #0 준비
  counting_arr = [0]*21
  res_arr = [0] * len(arr)

  #1 각각의 값들의 등장횟수 카운팅
  for i in range(len(arr)):
    counting_arr[arr[i]] += 1

  #2 등장횟수를 누적합으로 바꾸기
  for i in range(1,21):
    counting_arr[i] += counting_arr[i-1]

  #3 뒤에서부터 순회하며 누적합-1을 인덱스로 사용해서 결과값에 넣어줌
  for i in range(len(arr)-1,-1,-1):
    index = counting_arr[arr[i]]-1
    res_arr[index] = arr[i]
    counting_arr[arr[i]] -= 1
  
  return res_arr

print(counting_sort(arr))
# 결과값 ▶ [1, 2, 2, 6, 7, 8, 8, 13, 15, 19]
```

​     

> 코드 설명

* **#0**
  * `counting_arr` : `0`부터 `최대값`까지의 등장횟수를 기록할 수 있는 카운팅 배열
    * 여기서 알 수 있듯이 카운팅 정렬의 기본조건은 제한된 수의 범위다.
  * `res_arr` : 결과값을 담을 배열로 입력받은 배열과 길이가 같아야 한다.  
* **#1**
  * 입력받은 배열을 순회하면서 각 값들의 등장횟수를 카운팅 배열에 기록한다.
  * 각 값들은 카운팅 배열의 인덱스로 사용된다.
* **#2**
  * 카운팅 배열에 기록된 등장횟수를 그 이전까지의 누적합으로 바꾼다.
  * 인덱스 `0`번의 경우 누적합이 자기 자신이기에 `1`부터 순회한다.
  * 누적합으로 바꾸는 이유는 (오름차순)정렬에서 `누적합-1`은 해당 값의 최종 인덱스가 되기 때문이다.
* **#3**
  * 입력받은 배열을 뒤에서부터 순회하면서 각 값들을 `누적합-1` 위치에 넣는다.
  * 넣고나서는 해당 누적합을 `-1`해준다.
  * 뒤에서부터 순회하는 이유는 같은 값의 경우 기존의 순서를 유지하면서 넣어주기 위함이다.(안정정렬)
  * 안정정렬의 경우 각 값의 인덱스가 의미가 있거나 값이 2개 이상의 요소로 구성될 때 중요하다.





> 2개 이상의 요소로 구성된 배열을 정렬해주기

* 2개의 숫자로 이루어진 값을 요소로하는 배열이 있다고 해보자.
  * `[(7,22),(13,4),(9,88),(7,18),(45,23),(27,11)]`
  * 주어지는 조건: 최대값은 90

* 이 때 정렬 조건이 다음과 같다고 하자.
  * 제1원칙: 앞의 값이 큰 것을 위주로 정렬하라.
  * 제2원칙: 같은 값의 경우 뒤의 값이 큰 것이 앞에 오도록 정렬하라 

* 즉 2개의 조건을 사용해서 정렬을 해야 한다. 
* 이때 카운팅 정렬을 사용해서 정렬해보자.



> ★ 2개 조건에 대해 카운팅 정렬을 사용해서 정렬할 때 기본 생각

* **우선순위가 낮은 기준으로 먼저 정렬**하고 **이후에 우선순위가 높은 기준으로 정렬**한다.
* 이렇게 하면 **우선순위가 높은 기준으로 정렬할 때, 같은 값의 경우 먼저 정렬해놓은 우선순위가 낮은 기준을 따르게 된다**.(안정정렬의 특징)    
* 카운팅 정렬 함수 구현에 있어서 **정렬 기준이 되는 인덱스 값을 인자로 받아서 사용**하게끔 함수를 바꾸자.



> 코드

```python
arr = [(7,22),(13,4),(9,88),(7,18),(45,23),(27,11)]  # 최대값은 90(문제조건에 주어짐)



def counting_sort(idx,arr):
    # idx:내가 정렬하려는 기준 요소
     
    # 카운팅 배열 생성(최대값 사용)
    cnt = [0] * 91
     
    # 정렬결과 담을 배열
    sort_arr = [0] * len(arr)
     
    #1 등장횟수 카운팅
    for i in range(len(arr)):
        cnt[arr[i][idx]] += 1
         
    #2 누적 (카운팅 배열의 값들을 합으로 누적한 결과로 바꿈)★
    for i in range(1,len(cnt)):
        cnt[i] += cnt[i-1]
         
    #3 정렬하여 넣기
    for i in range(len(arr)-1,-1,-1): #뒤에서부터 순회(stable sort위해서)
	    index = cnt[arr[i][idx]]-1
        sort_arr[index] = arr[i]
        cnt[arr[i][idx]] -= 1
     
    return sort_arr

#4
# 우선순위가 낮은 뒤의 값을 기준으로 정렬
arr = counting_sort(1,arr)
# 우선순위가 높은 앞의 값을 기준으로 정렬
arr = counting_sort(0,arr)

print(arr)

```

   

> 코드 설명

* 작동 순서를 기억하는게 중요하다

* **#1**

  * 등장횟수 카운팅

* **#2**

  * 등장횟수를 사용해서 누적합 만들기

* **#3**

  * 뒤에서부터 순회하기
  * `누적합-1`을 인덱스로 결과에 해당 값 넣기 
  * `cnt[arr[i][idx]]`: 현재 정렬대상 값에서 정렬기준이되는 값의 누적합
    * 누적합에서 `-1`을 해줘야 결과값 인덱스가 된다.

* **#4**

  * 우선순위가 낮은 기준부터 정렬해줘야 한다.

    ▶ 우선순위가 낮은 기준으로 정렬한 상태는 우선순위가 높은 정렬 과정에서 안정정렬상태(기본상태)가 된다.

  