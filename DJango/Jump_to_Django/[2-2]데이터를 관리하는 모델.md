# 데이터를 관리하는 모델

출처: https://wikidocs.net/70650      



> 기본

* 장고는 `모델`로 데이터를 관리한다. 
  * 장고는 `모델`을 이용해서 해당 `모델`이 사용하는 `데이터 베이스 테이블`을 만든다.
  * 모든 모델은 `app`의 하위 항목으로 존재한다.
    * 예시: `프로젝트`(웹사이트) ▷ `app`(질문게시판_웹페이지) ▷ `model`(질문) , `model`(답변 ),...
  * 장고는 모델을 사용해서 데이터 베이스 테이블을 만드는데, 이 모델은 `app`에 종속되어 있다.
  * 따라서 장고에 `app`을 등록을 해야 `app` 하위의 모델을 가지고 데이터 베이스 테이블을 만들 수 가 있다.
* 장고에서는 `SQL DB`를 사용해서 데이터를 저장, 관리하지만 직접 `SQL`문으로 이를 통제하지는 않는다.
  * `SQL`문 대신 장고에서는 파이썬 언어를 통해 데이터를 관리한다. 

* 이로서 장고 사용자는 `DB`마다 다른 `SQL`문법에 대해 고민하지 않아도되고 파이썬만으로 쉽게 데이터를 다룰 수 있게 된다.  
  * 이러한 장고의 기능을 `ORM`(`Object Relational Mapping`)이라고 한다.
  * `ORM`: (장고에서)파이썬으로 데이터 작업을 가능하게 해주는 기능으로 파이썬 명령어를 SQL쿼리문으로 바꿔서 실행시켜준다.    





> 모델 만들기

* 장고에서는 `모델`을 클래스로 생성한다.







> 프로젝트, app, 모델에 대한 기본 내용

* 장고는 프로젝트(웹사이트)를 생성할 때 기본적인 `app`들이 생성이된다.

* 기본`app`이외에 사용자가 `app`을 만들고 해당 `app`을 통해 데이터 베이스 작업을 하고 싶다면, `app`을 장고에 인식시켜줘야한다.
  * 장고는 모델을 이용해서 

* 사용자가 만든 `app`을 장고에 인식시키기 위해서는 프로젝트 폴더의 `config/settings.py` 파일을 열어서 `INSTALLED_APPS` 항목에 해당 `app`을 추가시켜줘야 한다.

* 추가 형태의 예시는 다음과 같다. (사용자가 `pybo`라는 `app`을 만들어서 장고에 인식시키고자 하는 경우)

  `'pybo.apps.PyboConfig'`

  * pybo.apps.PyboConfig는 **pybo/apps.py**에 있는 **PyboConfig**라는 클래스를 가리킨다.

  * 어떤 `app`을 만들든 생성과 동시에 해당 디렉토리에`apps.py`가 생성되고 해당 파일에 `앱이름+Config`라는 클래스가 생성된다.

  * 클래스의 구성은 다음과 같다.

    ```python
    # pybo라는 app의 apps.py 파일
    
    from Django.apps import AppConfig
    
    class PyboConfig(AppConfig):
        name = 'pybo'
    ```

    







> (app 등록 후) app의 하위에 있는 모델을 사용해서 데이터 베이스 테이블 만들기 

1. `makemigrations`로 테이블 작업 파일 생성
   * 테이블을 생성하는 migrate 명령어를 실행시키기 위해서는 **테이블 작업 파일**이 필요하다.
   * `makemigrations`는 **테이블 작업파일**을 만드는 명령어다.
   * (실제 명령어 전체) `python maange.py makemigrations`     
   * 해당 명령어를 실행하면 `프로젝트디렉토리/migrations/0001_initial.py`라는 파일이 자동 생성된다.



2. `migrate`로 테이블 생성
   * `migrate` 명령어를 실행하면 장고는 등록된 `app`에 있는 모델을 참조하여 실제 테이블을 생성한다.
   * (실제 명령어 전체) `python manage.py migrate`
   * 이렇게 명령어를 실행하면 프로젝트의 Database 파일에 app의 모델들을 위한 테이블이 생성된다.



※ 모델의 속성(클래스의 attribute)이 추가되거나 변경되는 경우 makemigrations, migrate 명령을 다시 실행해야 변경사항이 반영이 된다. 

▶ 다만 모델의 메서드(클래스의 메서드)가 추가되거나 변경되는 경우는 해당 명령을 실행할 필요가 없다.

▶ 속성값은 데이터 베이스에 바로 기록되는 부분이지만, 메소드의 경우 실행할 때마다 해당 클래스로 가서 읽는 것이다. 따라서 따로 데이터 베이스에 수정사항을 반영할 필요가 없다.





> (만들어진 테이블을 가지고) 데이터를 생성하고 저장하고 조회하기

1. **장고 명령어를 입력할 셸 창을 실행**한다.
   * 자옥에서 데이터 베이스를 관리할 때는 `SQL`이 아닌 `python`을 사용한다. 
   * 이 `python`을 입력하기 위한 장고 명령어 셀을 실행한다.
   * 장고 셸 실행 명령어:`python manage.py shell`
   * 장고 셸은 파이썬 셸과 차이가 있다.(장고 셸은 장고에 필요한 환경들이 자동으로 설정된다.)    



2. **데이터를 수정,관리할 모델을 장고 셸에 `import`**한다.
   * 클래스로 해당 모델을 불러온다.
   * `from pybo.models import model1,model2`    



3. **불러온 모델(클래스)로 모델 객체를 만들어서 데이터를 수정**한다. 

   ```python
   q = model1(subject='데이터 입력', content='데이터 입력', create_data = timezone.now())
   ```

   * `model1` 클래스를 사용해서 객체를 만들고 객체의 속성값(attribute)에 데이터를 입력해준다. 
     * 위 `model1`의 클래스 코드를 보면 `subject`와 `content` 그리고 `create_date`가 속성값으로 설정되어 있다. 
     * 이때 입력값은 클래스 코드에서 속성값에 지정된 데이터 타입과 같은 타입의 데이터여야 한다.
     * 위에서는 `create_date`에 `timezone.now()`라는 날짜속성의 데이터를 입력했다. 
       * 실제 `model1` 클래스에서 `create_date`라는 속성값에는 `DataTimeField`라는 데이터 타입이 지정되어 있어야 한다.     



4. 데이터 수정이 끝났으면 **해당 객체를 저장**한다.
   * `q.save()`



5. 모델 데이터가 잘 생성되었는지 확인하기 위해서 **모델 객체의 id를 확인**해본다.
   * `q.id`
   * 장고에서는 데이터(모델 객체)를 데이터 베이스에 생성시, 고유한 `id`값을 자동으로 넣어준다.
   * `id` 값은 사용자가 데이터를 하나씩 생성할 때마다 1씩 증가한다. 



6. **해당 모델의 모든 데이터를 조회**해보자. 
   * 어떤 모델의 모든 데이터를 조회하기 위한 명령어는 아래와 같다.
   * `모델명.objects.all()`
   * 장고에서 저장된 모델 데이터는 `모델명.objects()`를 사용해서 조회할 수 있다. 
   * 여기에 `.all()`을 붙이면 해당 모델의 모든 객체가 반환된다. 





> 모델 객체를 조회하는 두 가지 방법 ▶ 차이점을 알고 있어야 한다

1. `filter`
   * `모델객체이름.objects.filter(속성=값)` : 해당 속성값을 가진 객체를 반환
   * `filter`의 경우 해당 속성을 가진 모든 객체를 반환한다. ★ 즉, 여러개의 객체를 탐색할 때 사용한다.
     * 물론 해당 속성을 가진 객체가 1개인 경우 1개만 반환한다.
   * 해당 속성값을 가진 객체가 없는 경우 비어있는 결과값을 반환한다.(Error발생 X)
2. `get`
   * `모델객체이름.objects.get(속성=값)` : 해당 속성값을 가진 객체 하나를 반환
   * `filter`가 해당 조건을 만족하는 모든 객체를 반환하는데반해 `get`은 오직 하나의 객체만 반환한다.
   * 해당 속성값을 가진 객체가 없는 경우 Error를 발생시킨다.