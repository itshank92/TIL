## 가장 긴 팰린드롬 부분 문자열

출처: https://leetcode.com/problems/longest-palindromic-substring

​     



> 문제

가장 긴 팰린드롬 부분 문자열을 출력하라.    





> 입력과 출력

```
Input: s = "babad"
Output: "bab"
Note: "aba" is also a valid answer.
```

```
Input: s = "cbbd"
Output: "bb"
```

```
Input: s = "a"
Output: "a"
```

```
Input: s = "ac"
Output: "a"
```

> 생각

* 팰린드롬의 형태는 크게 두가지다.

  * 짝수길이의 팰린드롬 (A-B-C-C-B-A)

  * 홀수길이의 팰린드롬 (A-B-C-B-A)    

    

* 두 가지의 팰린드롬을 각각을 판별하기 위한 포인터를 사용한다.

  * 짝수길이 팰린드롬 판별에는 i, i+1  포인터가 사용된다.

  * 홀수길이 팰린드롬 판별에는 i, i+2 포인터가 사용된다.

  * 각각의 포인터 왼쪽과 오른쪽문자를 가리킨다.

  * `문자열[왼쪽포인터] == 문자열[오른쪽포인터]`인 경우, 
    왼쪽 포인터는 -1해주고 오른쪽 포인터는 +1 해줘서 다음 쌍도 팰린드롬인지 확인한다.

  * 팰린드롬이 아닌 경우 `문자열[왼쪽포인터+1 : 오른쪽포인터]`를 해줘서 해당 팰린드롬을 얻는다.   

    

* 문자열의 각 문자들을 순회하면서, 짝수길이 포인터와 홀수길이 포인터를 가동시킨다.

  * 가동이 되는 경우 결과값을 저장하고 다음번 문자로 넘어간다.
  * 가동이 안되는 경우 다음번 문자로 넘어간다.      



* 주의 사항

  1. 포인터에 해당하는 문자 비교시, 왼쪽 포인터와 오른쪽 포인터의 범위를 먼저 확인하고 수행한다.

  2. 문자열의 각 문자 순회시 가장 마지막 문자는 확인할 필요가 없다.

     * 현재 풀이에서는 늘 다음문자(짝수포인터)와 다다음문자(홀수포인터)를 확인하는 방식을 사용하고 있기 때문이다.
     * 마지막 문자는 다음에 오는 문자가 없기에 팰린드롬 확인이 불가능하다.

     * 따라서 문자열 순회시 `range(len(문자열)-1)`을 하면 된다. 







> 코드

```python
def longest_pailndrome(s):
    def expand(left,right):
        while left >= 0 and right < len(s) and s[left] == s[right]:
            left -= 1
            right += 1
        return s[left+1:right]
    
    # 예외처리
    if len(s) < 2 or s == s[::-1]:
        return s
    
    result = ""
    # 문자열 순회
    for i in range(len(s)-1):
        result = max(result, expand(i,i+1), expand(i,i+2),key=len)
        
    return result    
```

​     

> 코드 생각

* 문자열을 순회하면 팰린드롬 씨앗을 탐색한다.

  * 팰린드롬 씨앗은 팰린드롬 내부의 가장 중앙에 있는 부분을 뜻한다.
  * 짝수 팰린드롬 씨앗은 ㅁㅁㅁㅁ**AA**ㅁㅁㅁㅁ와 같은 형태로 존재하고 
  * 홀수 팰린드롬 씨앗은 ㅁㅁㅁ**AㅁA**ㅁㅁㅁ와 같은 형태로 존재한다. 

  

* 이렇게 씨앗을 찾다가 씨앗이 발견되면 그 씨앗을 기점으로 팰린드롬을 확장한다.

  * 씨앗을 찾던 포인터들을 각각 양옆으로 한 칸씩 이동시키면서 팰린드롬 여부를 확인한다.



* `max`함수 역시 `key = function`을 사용할 수 있다. 