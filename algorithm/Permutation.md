# 순열만들기



#### 순열을 만드는 4가지 방법: 반복, 재귀, 비트연산, 스왑

​    

> 순열의 기본 아이디어

0. 순열은 기본적으로 각 자리에 대해 모든 요소가 오는 경우를 생각하는 것이다.
   (물론 한번 쓰인 요소는 뒤에는 못씀)     

   

1. 따라서 순열의 기본은 일단 만들어야 하는 **순열의 크기가 가장 바깥쪽에서 순회**해야 한다는 것이다.

   * 즉, **순열의 각 자리를 순회하는 것이 가장 큰 틀**이 된다.      

     

2. 순열의 각 자리를 순회하면서 **각 자리에 모든 요소가 한번씩 들어갈 수 있도록 요소 순회를 수행**한다.

   * 즉, 거시적으로는 순열의 각 자리별 순회를 하면서 **내부적으로 각 자리에 대해서는 요소별 순회**를 하는 것이다. 

     ```python
     for 각 자리 in range(순열의 크기): 
         for 각 요소 in 입력Array:
     
     # 크게는(바깥에서는) 순열의 각 자리를 순회하고,
     # 작게는(안쪽에서는) 각 요소별 순회를 수행한다. 
     ```

     ​     

     

3. (각 요소별 순회를 하며) **해당 순열 자리에 요소를 사용하는 경우와 사용하지 않는 경우 모두 진행**한다.

   * 요소를 사용하는 경우, 요소 사용에 체크하고 다음 순열자리로 넘어간다.
   * 요소를 사용하지 않는 경우, 앞서 체크한 요소 사용을 해제하고 다음 순열자리로 넘어간다.     

   







> 코드_ 일반 재귀 사용

```python
## 순열 재귀

# arr:순열대상 리스트, n:순열의 갯수, sel:순열을 담는 리스트, check: 사용한 요소 표시 리스트 
arr = [1,2,3]
n = 3  
sel = [0] * n
check = [0] * n

def perm(idx):  ## idx는 sel(결과값)의 포인터
  
  #1 종료조건
  ## sel이 꽉찬 경우(= idx(포인터)가 sel 범위 밖을 가리키는 경우)종료
  if idx == n:
    print(sel)
  
  else:
    #2 arr의 모든 요소를 순회하면서 사용한 적 없는 요소를 찾는다.
    ## i는 arr의 포인터
    for i in range(n):
        
      #3 사용한 적 없는 요소를 찾은 경우
      if check[i] == 0: ##  check[i]는 arr[i] 사용했는지 안했는지 확인하는 것
        sel[idx] = arr[i] # 결과값에 넣고 
        check[i] = 1  # 사용여부를 업데이트해주고 
        perm(idx+1)   # 재귀를 통해 idx+1로 넘어간다.
        check[i] = 0  # 재귀가 끝났으면 다시 사용여부를 취소하고 for문으로 돌아간다.

perm(0)      
```

​    

* **#1 종료조건**
  * 종료조건은 순열이 완성된 경우로 , 순열의 포인터(`idx`)의 값으로 판별한다.
* **#2 각 요소 순회**
  * 순열에 대한 순회는 `idx`로 진행하고 각 요소에 대한 순회는 `for`문으로 수행한다.
    * 이렇게 하면 각각의 `idx`에 대해(=각각의 순열 자리에 대해) 모든 요소를 넣었다 빼 볼 수 있다.
  * 각 요소별 순회시 사용하는 변수 `i`는 요소에 대한 포인터가 된다.
* **#3 각 요소에 대해서는 넣느냐 넣지 않느냐의 작업이 수행된다.**
  * 이 작업에 앞서 현재 순열에서 해당 요소를 미리 사용한 경우는 제외한다.
  * 이를 위해 `check[i]` 를 통해 해당 요소의 사용 여부를 판별한다.
  * 일단 넣을 때는 `check[i]` 를 `1`로 바꿔서 바로 이어서 수행할 순열의 재귀 경로에서 해당 요소를 재사용하지 않도록 해준다.
  * 재귀가 끝났으면 `check[i]` 를 다시 `0 `으로 바꿔서 사용하지 않는 경우에 대한 순열을 진행한다.
    * 사용하지 않는 경우 `idx` 에 변동이 없으니 재귀가 아닌 다시 `for` 문으로 돌아가 순열이 진행된다. 





> 코드 _ 비트사용 (재귀도 사용)

```python
## 순열 비트

#1 특징(check가 없다)
arr = [1,2,3]
n = 3
sel = [0] * n  

#2 특징(check가 인자로 들어간다)
def perm(idx,check):
  
  #3 종료조건
  if idx == n:
    print(sel)
    return
  
  #4 요소의 각 자리에 대해 순회
  for j in range(n):
    #5 check을 이진수로 바꾼 수의 j번째 자리의 수가 1이면 1<<j를 반환, 아니면 0을 반환
    ## check라는 이진수를 이미 이전에 만든 check다. 
    ## 따라서 어떤 인덱스가 1이라는 것은 해당 arr[인덱스]가 이미 사용되었다는 것을 의미한다. 
    if check & (1<<j): 
      continue
    
    # j번째 인덱스의 arr값이 아직 사용안되었다면 sel[idx]에 넣어주고 다음번으로 넘어감
    sel[idx] = arr[j]
    # or연산으로 인해 check의 j번째 요소가 0에서 1로 변할것이다.(결과값은 십진수로 나옴)
    perm(idx+1, check | (1<<j)) 
    # 재귀를 끝나고 돌아오면, check는 원래 값(-해당 i는 사용안된 경우)으로 다음 i로 넘어감
    
  
perm(0,0)

## for j in range(n)에서 n이 3이면 j는 0,1,2가 된다.
## 0,1,2번째 자리가 1인지 아닌지 check와 비교하면서 1이 아니면 1로 만들고
## 1이면 다음으로 넘어가는 방식으로 작동한다. 
## check는 1<<j(0~2)하고만 연산작업이 이뤄지기에 000 ~ 111사이로 나온다
## check는 해당 자리를 채우고 재귀로 다음번으로가서 다시 순회하면서 남은 자리를 또 채운다.
## 그리고 끝나면 다시 돌아오는데 돌아오는 순간 원래의 check로 돌아오기에 다음자리를 채우는 방식으로 작동한다.
## 000은 *001이 되고 011, 111이 된다. 그리고 다시 돌아오면 *001에서 101로 된다. 
```

​    

* **#1 비트연산의 특징**

  * 비트로 순열을 만드는 경우 `check` 리스트가 따로 없다.

  * 이는 `check` 를 재귀 함수의 인자로 넣기 때문이다.

  * `check` 는 십진수로 들어가지만 내부적으로는 이진수 연산(`binary operation`)를 통해 체크리스트로 사용된다.    

    

* **#2 비트연산에는 `check`가 인자로 들어간다. (각 순열자리를 가리키는 `idx`는 당연)**    

  

* **#3 종료조건**

  * 순열의 모든 자리가 입력되었다면(=순열자리의 포인터가 n을 가리키면) 종료    

  

* **#4 각 순열 자리에 대해 모든 요소의 순회가 수행된다.**

  * `for j in range(n)`에서의 `j`는 `1<<j`로 사용되어 각 자리수를 판별하는데 사용된다. 
  * `check` 는 `0(=000)`이 입력되기에 각각의 `1<<j`에 대해서 `001`, `010`, `100`으로 바뀌어 다음 재귀로 넘어간다. (해당 순열 자리에 모든 요소가 입력된다)    

  

* **#5 check에 대해서 각 요소가 존재하는지 판별**

  * 요소가 순열에 이미 사용된 경우 `for`문을 통해 다음으로 넘긴다.

  * 요소가 아직 사용되지 않은 경우 순열(`sel`)에 해당 요소를 넣고 재귀를 통해 `idx+1`로 넘어간다.

    * 이때, `|` 연산을 통해 업데이트된 `check` 를 재귀 함수에 넣어준다. 

  * 재귀가 끝난 경우 자동으로 원래의 `check` 로 돌아온다.

    * 즉, 해당 요소를 사용하지 않았던 경우가 되고 `for` 문의 다음 요소로 넘어간다.
    * 해당 순열 자리(`idx`)에 해당 요소 `arr[i]` 를 사용하지 않은 경우가 이렇게 커버된다.    

    

  

> 비트 연산(|) 이해

```python
# 8은 이진수로 1000
print(8 | (1<<0)) # 1000 | 0001 ▶ 1001(9)
print(8 | (1<<1)) # 1000 | 0010 ▶ 1010(10)
print(8 | (1<<2)) # 1000 | 0100 ▶ 1100(12)
print(8 | (1<<3)) # 1000 | 1000 ▶ 1000(8)  

# | 연산은 각 자리별로 둘다 0인 경우를 제외하고 1이 되는 연산이다.

## 결과값
# 9
# 10
# 12
# 8
```

​    

> 코드_ 스왑

```python
## 스왑을 이용해서 순열 만들기

#1
arr = [1,2,3]
n = 3


def swap_perm(idx):
    #2 종료조건
    if idx == n-1:
        return arr
    
    #3 ★현재 바꾸는 순열 자리포함 이후의 요소에 대해서만 스왑진행
    # "내자리에 오고싶은 애들 한번씩 와서 앉아봐!!"
    for j in range(idx,n):
        arr[idx],arr[j] = arr[j],arr[idx]
        swap_perm(idx+1)
        # 위에서 바꾼 것과 동일하게 바꿔줘야 원본이 복원된다.
        arr[idx],arr[j] = arr[j],arr[idx]
        
  
swap_perm(0) 
```

* 스왑방식의 경우 원본 배열을 사용해서 순열을 만들기에 메모리에서 이점이 있다. 

  * 따로 `check`나 `sel`과 같은 리스트가 필요 없다.

* **#1**

  * 스왑방식은 결과값을 담을 `sel`이나 요소 사용 여부를 체크하는 `check` 가 필요없다.
  * 결과값이 필요없는 이유: `arr` 자체의 요소의  위치를 바꿔서 순열을 출력한다.
  * 체크리스트가 필요없는 경우: 순열의 각 자리별로 올 수 있는 요소만 다루는 코드로 작성되었다.

* **#2**

  * 종료조건은 `idx` 가 `n-1` 인 경우다.
  * 사실 `idx` 가 `n-1` 인 경우에도 아래 `for` 문은 작동한다. (`n-1`에 대해서 작동)
  * 하지만 `idx` 가 `n-1` 인 경우, 스왑할 수 있는 대상은 오직 자기자신밖에 없기에 결과값은 스왑 이전과 
    차이가 없다.
  * 따라서 `idx`가 `n-1`인 경우 바로 결과값을 출력한다.

* **★★ #3 ★★**

  * 스왑은 기본적으로 기존의 배열(`arr`)을 기준으로 작동한다.

  * 따라서 배열의 인덱스는 순열의 자리이기도 하면서, 해당 요소를 뜻한다.

  * 배열의 첫번째 자리(순열의 첫번째 자리)에는 어떤 요소가 올 수 있을까?

    * 모든 요소가 올 수 있다.
    * 이 때 우리는 **스왑**을 통해 모든 요소를 첫번째 자리로 불러온다. 
    * **즉, 모든 자리의 요소를 첫번째 자리의 요소와 스왑함으로서 첫번째 자리의 모든 경우의 수를 만든다.**

  * 배열의 두번째 자리(순열의 두번째 자리)에는 어떤 요소가 올 수 있을까?

    * 두번째 자리의 경우 모든 요소가 올 수 있다.

    * 따라서 요소를 순회하기 위한 `for`문을 `range(n)`에 대해 수행해야 된다고 생각해볼 수 있다.

    * **하지만 배열의 첫번째 요소는 이미 앞선 스왑작업에 의해 두번째 자리에 놓인 적이 있다.**
      (두번째 요소와 스왑하였을 때)

    * 따라서 첫번째 요소를 제외한 요소들에 대해 스왑을 수행하게 된다. 

      ```python
      for j in range(idx,n)
      ```

  * 배열의 세번째 자리(순열의 세번째 자리)에는 어떤 요소가 올 수 있을까?

    * 원칙적으로는 모든 요소가 올 수 있다.
    * 하지만 이미 첫번째, 두번째 요소는 첫번째 스왑, 두번째 스왑을 통해 세번째 자리에 놓인 적이 있다.
    * 따라서 (`n`이 3인 경우) 세번째 요소만이 배열의 세번째 자리에 올 수 있는 요소가 된다.
      * 상황이 이렇기에 `idx`가 `n-1`인 경우는 따로 스왑을 진행하지 않는 것이다. 







#### 중복순열만들기(재귀)

> 코드 

```python
# n은 만들려는 중복순열 결과값의 인덱스 포인터, k는 중복순열길이, m은 사용할 숫자(1부터 m까지)
# p는 중복순열 결과담을 배열
def f(n,k,m):
  if n == k:
    print(p)
  else:
    for i in range(1,m+1):
      p[n] = i
      f(n+1,k,m)

k = 5
p = [0] * k
f(0,k)

```





