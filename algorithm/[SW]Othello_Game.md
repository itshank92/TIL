## 오셀로 게임



> 정리

* 백준의 오델로 게임과 같은 원리로 푸는 문제다. (백준: https://www.acmicpc.net/problem/15671)

* 전형적인 구현 문제로 다음과 같은 부분을 조심해야 한다.

  1. 문제에서 주어진 조건을 모두 이해한다음 풀어야 한다.

     * 물론 모든 문제가 문제 조건에 대한 이해가 중요하지만, 구현문제는 특히 조건이 복잡하기때문에 조건에 대해 이해하는데 의식적으로 평소보다 많은 시간을 할애해야 한다.
     * 문제에서 주어지는 예시를 여러번 반복해서 직접 수행하며 조건을 완전히 이해한다.

  2. 문제를 풀기위해 몇개의 단계로 나눠서 각각의 단계별 함수를 구현한다.

     * 모듈화된 풀이를 만든다고 생각하고 접근해야 한다.
     * 하나의 거대한 함수가 아닌 여러 단계로 풀어야 푸는 과정에서 헷갈림이 적고 디버깅에 좋다.    

     

  

> 문제 관련

* 조건을 이해하는데 시간이 조금 걸렸다.
* 다행히 문제에서는 오델로라는 게임에서 나올수 있는 경우 중 일부 경우만으로 한정해줬기에 수월하게 풀 수 있었다.
* 단지 애초에 padding을 한 것을 잊은채 인덱싱을 잘못해서 10분정도 디버깅을 하는데 시간을 썼다.
  *  row와 col이 1로 시작하는 것을 전제로 입력값이 주어졌는데 이를 바로 사용하려고 padding을 해줬다. 
  * padding은 전체 입력값의 테두리에 해줬는데 마지막에 입력값을 순회할 때 padding을 한 것을 잊었다.
  * **padding을 해주었다면 인덱싱과 슬라이싱을 할 때, 또 for문으로 순회할 때 주의하자.**     



> 코드

```python
# 8방향 확인하며 자신과 같은 말 나올때까지 검색하고 색 바꿔주는 함수
def allaround(r,c,turn):
  # 최상단좌측부터 시계방향
  mr = [-1,-1,-1,0,0,1,1,1]
  mc = [-1,0,1,-1,1,-1,0,1]
  for i in range(8):
    # 시작 좌표 설정
    nr,nc = r + mr[i], c + mc[i]
    # 시작 좌표 유효한지 검사(자신과 다른 말인지)
    if all(1<=x<=n for x in (nr,nc)) and ob[nr][nc] != 0 and ob[nr][nc] != turn:
      # 유효하다면 자신과 같은 말 or 0이 나올 때까지 탐사
      # 탐사를 위해 이동 좌표를 담을 배열 생성
      loc = []
      while all(1<=x<=n for x in (nr,nc)):
        # 자신과 같은 말이 나온 경우
        if ob[nr][nc] == turn:
          # 이동좌표배열 영역을 순회하며 자신과 같은 색으로 바꿔줌
          for cr,cc in loc:
            ob[cr][cc] = turn
          break
        
        # 0이 나온 경우
        if ob[nr][nc] == 0:
          # 끝냄
          break
        
        # 위 두가지 경우가 아니라면 
        # 1. loc에 해당 좌표를 담고
        loc.append((nr,nc))
        # 2. nr,nc를 업데이트하고 다시 while문 수행
        nr,nc = nr + mr[i], nc + mc[i]



# 입력값 받기
n,m = map(int,input().split())

# n*n판만들기 (0으로 padding)
# othello board
ob = [[0]*(n+2) for _ in range(n+2)]
print(*ob, sep = "\n")

# 초기 셋팅(가운데 돌 놓기)
mid = n//2
ob[mid][mid],ob[mid+1][mid+1] = 2, 2
ob[mid][mid+1],ob[mid+1][mid] = 1, 1

# 입력값 받아서 판을 짜보자
for _ in range(m):
  r,c,turn = map(int,input().split())
  ob[r][c] = turn
  allaround(r,c,turn)

# 카운트를 하고 승자를 가리자
b_cnt, w_cnt = 0,0
for i in range(1,n+1):
  for j in range(1,n+1):
    if ob[i][j] == 1:
      b_cnt += 1
    elif ob[i][j] == 2:
      w_cnt += 1

print(b_cnt,w_cnt)
```



> 8방향 확인 함수를 만들기 위해 시험삼아 만든 것

* 8방향을 좌측 상단부터 시계방향으로 돌면서 숫자를 채워주는 코드

```python
#9*9크기의 0으로 채워진 2차원 배열을 만든다.
n = 9
map_ = [[0]*n for _ in range(n)]

# 초기 2차원 배열을 출력한다.
print(*map_,sep="\n")

# 최상단좌측부터 시계방향으로
mr = [-1,-1,-1,0,0,1,1,1]
mc = [-1,0,1,-1,1,-1,0,1]

# 8방향을 돌면서 각 방향별로 숫자를 1부터 채워가는 함수
def allaround(r,c):
  nr,nc = r,c
  for i in range(8):
    # 시작 좌표 설정
    nr,nc = r + mr[i], c + mc[i]
    # 시작 좌표 유효한지 검사
    if all(0<=x<n for x in (nr,nc)):
      # 유효하다면 영역 끝까지 해당 방향으로 탐사
      while all(0<=x<n for x in (nr,nc)):
        map_[nr][nc] = i+1
        nr,nc = nr + mr[i], nc + mc[i]

# 4,4를 기준으로 시계방향으로 숫자를 채운다.
allaround(4,4)

print("--------------------")

print(*map_,sep="\n")

## 결과값(원본배열과 결과배열이 -----를 기준으로 나뉘어 출력된다)
"""
[0, 0, 0, 0, 0, 0, 0, 0, 0]
[0, 0, 0, 0, 0, 0, 0, 0, 0]
[0, 0, 0, 0, 0, 0, 0, 0, 0]
[0, 0, 0, 0, 0, 0, 0, 0, 0]
[0, 0, 0, 0, 0, 0, 0, 0, 0]
[0, 0, 0, 0, 0, 0, 0, 0, 0]
[0, 0, 0, 0, 0, 0, 0, 0, 0]
[0, 0, 0, 0, 0, 0, 0, 0, 0]
[0, 0, 0, 0, 0, 0, 0, 0, 0]
--------------------
[1, 0, 0, 0, 2, 0, 0, 0, 3]
[0, 1, 0, 0, 2, 0, 0, 3, 0]
[0, 0, 1, 0, 2, 0, 3, 0, 0]
[0, 0, 0, 1, 2, 3, 0, 0, 0]
[4, 4, 4, 4, 0, 5, 5, 5, 5]
[0, 0, 0, 6, 7, 8, 0, 0, 0]
[0, 0, 6, 0, 7, 0, 8, 0, 0]
[0, 6, 0, 0, 7, 0, 0, 8, 0]
[6, 0, 0, 0, 7, 0, 0, 0, 8]
"""
```

