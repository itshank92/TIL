### 거품정렬



출처: https://gyoogle.dev/blog/algorithm/Bubble%20Sort.html



> 개념

서로 인접한 두 원소의 대소를 비교하고, 조건에 맞지 않다면 자리를 교환하며 정렬하는 알고리즘    



> 과정

```python
def bubble_sort(nums:list):
    length = len(nums)
    for i in range(length):# 1
        for j in range(1,length-i): # 2
            if nums[j] < nums[j-1]:
                nums[j-1],nums[j] = nums[j],nums[j-1]
```

* 범위 설정 부분(#1,#2)을 이해하면 거품정렬을 이해할 수 있다.

* #1번 부분

  * 거품정렬시 비교 영역의 크기를 보면, 첫 순회시 모든 원소를 비교한다.
  * 그리고 순회가 증가함에 따라 계속해서 비교 영역의 크기는 1씩 줄어든다.
  * 첫 for문의 `i`는 거품정렬이 계속해서 비교 영역의 크기를 줄일 때 사용하는 변수다.

* #2번 부분

  * 첫 for문의 `i`를 이용해서 본격적으로 비교 영역을 설정하고 비교하는 부분이다.

  * 비교영역은 계속해서 1씩 줄어들고 이를 위해 `i`를 가져와서 `range`에 반영했다.

  * 자신보다 하나 이전의 원소를 비교하는 방식으로 코드를 작성했기 때문에, 인덱스는 1부터 시작한다.

    * ※ 따라서 리스트의 길이가 1이하인 경우 앞에서 예외처리를 해줘야 한다. ※

    

   

> 시간복잡도

비교 영역을 `(n-1)`부터 `1`씩 줄여가면서 `1`까지 비교를 수행하기 때문에 결과적으로`n(n-1)/2`가 된다. 즉, O(n^2)가 시간복잡도로 이는 최악의 경우와 최선의 경우 모두 동일하다.   

대상 배열이 정렬이 되어있던 안되어있던 매번 2개의 원소를 비교하기 때문에, 최선과 최악의 경우가 동일한 것이다.     



> 공간복잡도

주어진 배열 안에서 교환을 수행하기에 공간복잡도는 O(n)이다.    



> 장점

* 구현이 간단하고 직관적이라 이해가 쉽다
* 주어진 배열 내에서 교환이 이뤄지기에 따로 추가적인 메모리를 사용하지 않는다. 
  ▶ 제자리 정렬
* 안정 정렬(Stable Sort)이다. (안정정렬: 기존의 위치가 반영된 정렬방식(같은값인 경우 기존 순서 유지))

​    

> 단점

* 시간복잡도가 **항상** O(n^2)로 비효율적이다.
* 정렬되어 있지 않은 배열을 대상으로 하는 경우 교환(swap) 연산이 많이 일어난다.